"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/dashboard/institution",{

/***/ "./hooks/useContract.ts":
/*!******************************!*\
  !*** ./hooks/useContract.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useContract: function() { return /* binding */ useContract; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var wagmi__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! wagmi */ \"./node_modules/wagmi/dist/esm/exports/index.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! viem */ \"./node_modules/viem/_esm/index.js\");\n/* harmony import */ var _contracts_ExamManagement_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../contracts/ExamManagement.json */ \"./contracts/ExamManagement.json\");\n/* harmony import */ var _contracts_Certificates_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../contracts/Certificates.json */ \"./contracts/Certificates.json\");\n/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @chakra-ui/react */ \"./node_modules/@chakra-ui/react/dist/index.mjs\");\n\n\n\n\n\n\nconst EXAM_MANAGEMENT_ADDRESS = \"0x15B70b2C305c684Ef6335b64b0CA430e481c3ac5\" || 0;\nconst CERTIFICATES_ADDRESS = \"0x91F73a8778C82983253fEC5C0a63f87beA461AFd\" || 0;\nconst EXAMINATIONS_ADDRESS = \"0x1cE1DF501cF629b04c6B647e5A7BDE8245BcE02A\" || 0;\nconst IDENTITY_ADDRESS = \"0xb8F6dE405c3A2876d0a14Fa08Ee5D92793bFbbA1\" || 0;\nconst SECURITY_UTILS_ADDRESS = \"0x705D62Df2879E56545e9A9A6381c6a8e200e390c\" || 0;\nconst TARGET_CHAIN_ID = 1337; // Local network chain ID\nconst useContract = ()=>{\n    const { address: account } = (0,wagmi__WEBPACK_IMPORTED_MODULE_3__.useAccount)();\n    const publicClient = (0,wagmi__WEBPACK_IMPORTED_MODULE_3__.usePublicClient)();\n    const { data: walletClient } = (0,wagmi__WEBPACK_IMPORTED_MODULE_3__.useWalletClient)();\n    const chainId = (0,wagmi__WEBPACK_IMPORTED_MODULE_3__.useChainId)();\n    const { connect } = (0,wagmi__WEBPACK_IMPORTED_MODULE_3__.useConnect)();\n    const toast = (0,_chakra_ui_react__WEBPACK_IMPORTED_MODULE_4__.useToast)();\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        examManagementContract: null,\n        certificatesContract: null,\n        examinationsContract: null,\n        identityContract: null,\n        securityUtilsContract: null,\n        isConnected: false,\n        isInitialized: false,\n        isLoading: false,\n        networkSwitchAttempted: false,\n        initializationAttempted: false,\n        initializationError: null\n    });\n    // Single effect to handle both network validation and contract initialization\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let isMounted = true;\n        let switchAttempts = 0;\n        const MAX_SWITCH_ATTEMPTS = 3;\n        const verifyNetwork = async (expectedChainId)=>{\n            try {\n                if (!publicClient) {\n                    console.error(\"Public client not available\");\n                    return false;\n                }\n                const currentChainId = await publicClient.getChainId();\n                console.log(\"Verifying network - Current: \".concat(currentChainId, \", Expected: \").concat(expectedChainId));\n                return currentChainId === expectedChainId;\n            } catch (error) {\n                console.error(\"Network verification error:\", error);\n                return false;\n            }\n        };\n        const waitForNetworkSwitch = async (expectedChainId)=>{\n            const maxAttempts = 30; // Increase max attempts to 30 (15 seconds total)\n            const interval = 500; // Check every 500ms\n            let attempts = 0;\n            while(attempts < maxAttempts){\n                const isCorrectNetwork = await verifyNetwork(expectedChainId);\n                if (isCorrectNetwork) {\n                    console.log(\"Network switch verified successfully\");\n                    return true;\n                }\n                await new Promise((resolve)=>setTimeout(resolve, interval));\n                attempts++;\n                console.log(\"Waiting for network switch... Attempt \".concat(attempts, \"/\").concat(maxAttempts));\n            }\n            console.error(\"تجاوز الحد الأقصى لمحاولات التحقق من تبديل الشبكة | Maximum network switch verification attempts exceeded\");\n            return false;\n        };\n        const switchNetwork = async ()=>{\n            if (!window.ethereum) {\n                throw new Error(\"MetaMask غير مثبت | MetaMask is not installed\");\n            }\n            try {\n                console.log(\"Attempting to switch network...\");\n                // First try to switch\n                try {\n                    await window.ethereum.request({\n                        method: \"wallet_switchEthereumChain\",\n                        params: [\n                            {\n                                chainId: \"0x\".concat(TARGET_CHAIN_ID.toString(16))\n                            }\n                        ]\n                    });\n                } catch (switchError) {\n                    // If network doesn't exist, add it\n                    if (switchError.code === 4902) {\n                        console.log(\"Network not found, adding...\");\n                        await window.ethereum.request({\n                            method: \"wallet_addEthereumChain\",\n                            params: [\n                                {\n                                    chainId: \"0x\".concat(TARGET_CHAIN_ID.toString(16)),\n                                    chainName: \"Ganache Local\",\n                                    rpcUrls: [\n                                        \"http://127.0.0.1:7545\"\n                                    ],\n                                    nativeCurrency: {\n                                        name: \"ETH\",\n                                        symbol: \"ETH\",\n                                        decimals: 18\n                                    }\n                                }\n                            ]\n                        });\n                    } else {\n                        throw switchError;\n                    }\n                }\n                // Wait for network switch to complete\n                console.log(\"Waiting for network switch to complete...\");\n                await waitForNetworkSwitch(TARGET_CHAIN_ID);\n                console.log(\"Network switch completed successfully\");\n            } catch (error) {\n                console.error(\"Network switch failed:\", error);\n                throw error;\n            }\n        };\n        const initializeContracts = async ()=>{\n            if (!isMounted || !publicClient) return;\n            // Reset state at the start of initialization\n            setState((prev)=>({\n                    ...prev,\n                    examManagementContract: null,\n                    certificatesContract: null,\n                    isInitialized: false,\n                    isLoading: true,\n                    initializationError: null\n                }));\n            try {\n                // 1. Validate dependencies\n                if (!account || !walletClient) {\n                    console.log(\"Core dependencies not ready:\", {\n                        hasAccount: !!account,\n                        hasWalletClient: !!walletClient\n                    });\n                    throw new Error(\"يرجى الانتظار حتى يتم تحميل جميع المتطلبات | Waiting for dependencies to load\");\n                }\n                if (!EXAM_MANAGEMENT_ADDRESS || !CERTIFICATES_ADDRESS) {\n                    console.error(\"Contract addresses missing:\", {\n                        EXAM_MANAGEMENT_ADDRESS,\n                        CERTIFICATES_ADDRESS\n                    });\n                    throw new Error(\"عناوين العقود غير مكونة | Contract addresses not configured\");\n                }\n                // 2. Network validation with retries\n                const isCorrectNetwork = await verifyNetwork(TARGET_CHAIN_ID);\n                if (!isCorrectNetwork) {\n                    if (switchAttempts >= MAX_SWITCH_ATTEMPTS) {\n                        throw new Error(\"تجاوز الحد الأقصى لمحاولات تبديل الشبكة | Maximum network switch attempts exceeded\");\n                    }\n                    switchAttempts++;\n                    console.log(\"Attempting network switch (\".concat(switchAttempts, \"/\").concat(MAX_SWITCH_ATTEMPTS, \")...\"));\n                    await switchNetwork();\n                    const finalCheck = await verifyNetwork(TARGET_CHAIN_ID);\n                    if (!finalCheck) {\n                        throw new Error(\"فشل في التحقق النهائي من الشبكة | Final network verification failed\");\n                    }\n                }\n                // 3. Contract deployment verification\n                console.log(\"Verifying contract deployments...\");\n                const [examCode, certCode] = await Promise.all([\n                    publicClient.getBytecode({\n                        address: EXAM_MANAGEMENT_ADDRESS\n                    }),\n                    publicClient.getBytecode({\n                        address: CERTIFICATES_ADDRESS\n                    })\n                ]);\n                if (!examCode || examCode === \"0x\") {\n                    throw new Error(\"عقد إدارة الاختبارات غير موجود | Exam Management contract not found\");\n                }\n                if (!certCode || certCode === \"0x\") {\n                    throw new Error(\"عقد الشهادات غير موجود | Certificates contract not found\");\n                }\n                // 4. Contract initialization\n                console.log(\"Creating contract instances...\");\n                // Create read-only contract instances\n                const examManagementRead = (0,viem__WEBPACK_IMPORTED_MODULE_5__.getContract)({\n                    address: EXAM_MANAGEMENT_ADDRESS,\n                    abi: _contracts_ExamManagement_json__WEBPACK_IMPORTED_MODULE_1__.abi,\n                    client: publicClient\n                });\n                const certificatesRead = (0,viem__WEBPACK_IMPORTED_MODULE_5__.getContract)({\n                    address: CERTIFICATES_ADDRESS,\n                    abi: _contracts_Certificates_json__WEBPACK_IMPORTED_MODULE_2__.abi,\n                    client: publicClient\n                });\n                // Create write-enabled contract instances\n                const examManagementWrite = walletClient ? (0,viem__WEBPACK_IMPORTED_MODULE_5__.getContract)({\n                    address: EXAM_MANAGEMENT_ADDRESS,\n                    abi: _contracts_ExamManagement_json__WEBPACK_IMPORTED_MODULE_1__.abi,\n                    client: walletClient\n                }) : null;\n                const certificatesWrite = walletClient ? (0,viem__WEBPACK_IMPORTED_MODULE_5__.getContract)({\n                    address: CERTIFICATES_ADDRESS,\n                    abi: _contracts_Certificates_json__WEBPACK_IMPORTED_MODULE_2__.abi,\n                    client: walletClient\n                }) : null;\n                if (!examManagementRead || !certificatesRead) {\n                    throw new Error(\"فشل في إنشاء عقود القراءة | Failed to create read contract instances\");\n                }\n                if (!examManagementWrite || !certificatesWrite) {\n                    throw new Error(\"فشل في إنشاء عقود الكتابة | Failed to create write contract instances\");\n                }\n                // 5. Contract testing\n                console.log(\"Testing contract connections...\");\n                try {\n                    const [isInstitutionResult, certificatesResult] = await Promise.all([\n                        examManagementRead.read.isInstitution([\n                            account\n                        ]),\n                        certificatesRead.read.getInstitutionCertificates([\n                            account\n                        ])\n                    ]);\n                    if (typeof isInstitutionResult === \"undefined\" || typeof certificatesResult === \"undefined\") {\n                        throw new Error(\"فشل في قراءة بيانات العقود | Failed to read contract data\");\n                    }\n                    console.log(\"Contract tests successful\");\n                } catch (error) {\n                    console.error(\"Contract test failed:\", error);\n                    throw new Error(\"فشل في الاتصال بالعقود | Contract connection test failed\");\n                }\n                // 6. Update state with initialized contracts\n                if (isMounted) {\n                    const newState = {\n                        examManagementContract: {\n                            isInstitution: async (address)=>{\n                                const result = await examManagementRead.read.isInstitution([\n                                    address\n                                ]);\n                                return result === true;\n                            },\n                            getInstitution: async (address)=>{\n                                return await examManagementRead.read.getInstitution([\n                                    address\n                                ]);\n                            },\n                            getInstitutionExams: async (address)=>{\n                                var _ref;\n                                return (_ref = await examManagementRead.read.getInstitutionExams([\n                                    address\n                                ])) !== null && _ref !== void 0 ? _ref : [];\n                            },\n                            getExamResults: async (examId)=>{\n                                var _ref;\n                                return (_ref = await examManagementRead.read.getExamResults([\n                                    examId\n                                ])) !== null && _ref !== void 0 ? _ref : [];\n                            },\n                            write: {\n                                updateInstitutionProfile: async (params)=>{\n                                    if (!examManagementWrite) throw new Error(\"عقد الكتابة غير متوفر | Write contract not available\");\n                                    const hash = await examManagementWrite.write.updateInstitutionProfile(params.args);\n                                    if (!hash) throw new Error(\"فشل في تحديث الملف الشخصي | Failed to update institution profile\");\n                                    return {\n                                        wait: async ()=>{\n                                            await publicClient.waitForTransactionReceipt({\n                                                hash\n                                            });\n                                        }\n                                    };\n                                },\n                                submitExamResults: async (params)=>{\n                                    if (!examManagementWrite) throw new Error(\"عقد الكتابة غير متوفر | Write contract not available\");\n                                    const hash = await examManagementWrite.write.submitExamResults(params.args);\n                                    if (!hash) throw new Error(\"فشل في إرسال النتائج | Failed to submit exam results\");\n                                    return {\n                                        wait: async ()=>{\n                                            await publicClient.waitForTransactionReceipt({\n                                                hash\n                                            });\n                                        }\n                                    };\n                                },\n                                registerStudents: async (params)=>{\n                                    if (!examManagementWrite) throw new Error(\"عقد الكتابة غير متوفر | Write contract not available\");\n                                    const hash = await examManagementWrite.write.registerStudents(params.args);\n                                    if (!hash) throw new Error(\"فشل في تسجيل الطلاب | Failed to register students\");\n                                    return {\n                                        wait: async ()=>{\n                                            await publicClient.waitForTransactionReceipt({\n                                                hash\n                                            });\n                                        }\n                                    };\n                                },\n                                updateExamStatus: async (params)=>{\n                                    if (!examManagementWrite) throw new Error(\"عقد الكتابة غير متوفر | Write contract not available\");\n                                    const hash = await examManagementWrite.write.updateExamStatus(params.args);\n                                    if (!hash) throw new Error(\"فشل في تحديث حالة الاختبار | Failed to update exam status\");\n                                    return {\n                                        wait: async ()=>{\n                                            await publicClient.waitForTransactionReceipt({\n                                                hash\n                                            });\n                                        }\n                                    };\n                                },\n                                createExam: async (params)=>{\n                                    if (!examManagementWrite) throw new Error(\"عقد الكتابة غير متوفر | Write contract not available\");\n                                    const hash = await examManagementWrite.write.createExam(params.args);\n                                    if (!hash) throw new Error(\"فشل في إنشاء الاختبار | Failed to create exam\");\n                                    return {\n                                        wait: async ()=>{\n                                            await publicClient.waitForTransactionReceipt({\n                                                hash\n                                            });\n                                        }\n                                    };\n                                },\n                                issueCertificate: async (params)=>{\n                                    if (!examManagementWrite) throw new Error(\"عقد الكتابة غير متوفر | Write contract not available\");\n                                    const hash = await examManagementWrite.write.issueCertificate(params.args);\n                                    if (!hash) throw new Error(\"فشل في إصدار الشهادة | Failed to issue certificate\");\n                                    return {\n                                        wait: async ()=>{\n                                            await publicClient.waitForTransactionReceipt({\n                                                hash\n                                            });\n                                        }\n                                    };\n                                }\n                            }\n                        },\n                        certificatesContract: {\n                            getInstitutionCertificates: async (address)=>{\n                                var _ref;\n                                return (_ref = await certificatesRead.read.getInstitutionCertificates([\n                                    address\n                                ])) !== null && _ref !== void 0 ? _ref : [];\n                            },\n                            write: {\n                                issueCertificate: async (params)=>{\n                                    if (!certificatesWrite) throw new Error(\"عقد الكتابة غير متوفر | Write contract not available\");\n                                    const hash = await certificatesWrite.write.issueCertificate(params.args);\n                                    if (!hash) throw new Error(\"فشل في إصدار الشهادة | Failed to issue certificate\");\n                                    return {\n                                        wait: async ()=>{\n                                            await publicClient.waitForTransactionReceipt({\n                                                hash\n                                            });\n                                        }\n                                    };\n                                }\n                            }\n                        },\n                        isConnected: true,\n                        isInitialized: true,\n                        isLoading: false,\n                        initializationError: null\n                    };\n                    setState((prev)=>({\n                            ...prev,\n                            ...newState\n                        }));\n                    console.log(\"Contract initialization complete\");\n                }\n            } catch (error) {\n                console.error(\"Initialization error:\", {\n                    error: error instanceof Error ? {\n                        name: error.name,\n                        message: error.message,\n                        stack: error.stack\n                    } : \"Unknown error\",\n                    state: {\n                        hasAccount: !!account,\n                        hasWalletClient: !!walletClient,\n                        hasPublicClient: !!publicClient,\n                        chainId: chainId,\n                        targetChainId: TARGET_CHAIN_ID\n                    }\n                });\n                if (isMounted) {\n                    setState((prev)=>({\n                            ...prev,\n                            examManagementContract: null,\n                            certificatesContract: null,\n                            isLoading: false,\n                            isInitialized: false,\n                            isConnected: false,\n                            initializationError: error instanceof Error ? error.message : \"Unknown error\"\n                        }));\n                    toast({\n                        title: \"خطأ في التهيئة | Initialization Error\",\n                        description: error instanceof Error ? \"\".concat(error.message, \" | يرجى التأكد من اتصال المحفظة والشبكة الصحيحة\") : \"حدث خطأ غير معروف | An unknown error occurred\",\n                        status: \"error\",\n                        duration: 5000,\n                        isClosable: true\n                    });\n                }\n            }\n        };\n        initializeContracts();\n        return ()=>{\n            isMounted = false;\n        };\n    }, [\n        account,\n        walletClient,\n        publicClient,\n        chainId,\n        toast\n    ]);\n    // Handle network changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _window_ethereum;\n        if ( true && ((_window_ethereum = window.ethereum) === null || _window_ethereum === void 0 ? void 0 : _window_ethereum.on)) {\n            const handleChainChanged = ()=>{\n                console.log(\"Network changed, resetting state...\");\n                setState((prev)=>({\n                        ...prev,\n                        examManagementContract: null,\n                        certificatesContract: null,\n                        examinationsContract: null,\n                        identityContract: null,\n                        securityUtilsContract: null,\n                        isInitialized: false,\n                        isConnected: false,\n                        isLoading: false,\n                        initializationError: null\n                    }));\n            };\n            window.ethereum.on(\"chainChanged\", handleChainChanged);\n            return ()=>{\n                var _window_ethereum;\n                if ((_window_ethereum = window.ethereum) === null || _window_ethereum === void 0 ? void 0 : _window_ethereum.removeListener) {\n                    window.ethereum.removeListener(\"chainChanged\", handleChainChanged);\n                }\n            };\n        }\n    }, []);\n    return {\n        examManagementContract: state.examManagementContract,\n        certificatesContract: state.certificatesContract,\n        examinationsContract: state.examinationsContract,\n        identityContract: state.identityContract,\n        securityUtilsContract: state.securityUtilsContract,\n        account,\n        isConnected: state.isConnected,\n        isInitialized: state.isInitialized,\n        isLoading: state.isLoading,\n        isCorrectNetwork: chainId === TARGET_CHAIN_ID,\n        initializationError: state.initializationError\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVc7d0JBQ1hHLHFCQUFxQjtvQkFDdkI7WUFDRjtZQUVBb0IsT0FBT0MsUUFBUSxDQUFDNEQsRUFBRSxDQUFDLGdCQUFnQkM7WUFDbkMsT0FBTztvQkFDRDlEO2dCQUFKLEtBQUlBLG1CQUFBQSxPQUFPQyxRQUFRLGNBQWZELHVDQUFBQSxpQkFBaUIrRCxjQUFjLEVBQUU7b0JBQ25DL0QsT0FBT0MsUUFBUSxDQUFDOEQsY0FBYyxDQUFDLGdCQUFnQkQ7Z0JBQ2pEO1lBQ0Y7UUFDRjtJQUNGLEdBQUcsRUFBRTtJQUVMLE9BQU87UUFDTDVGLHdCQUF3QkYsTUFBTUUsc0JBQXNCO1FBQ3BEQyxzQkFBc0JILE1BQU1HLG9CQUFvQjtRQUNoREMsc0JBQXNCSixNQUFNSSxvQkFBb0I7UUFDaERDLGtCQUFrQkwsTUFBTUssZ0JBQWdCO1FBQ3hDQyx1QkFBdUJOLE1BQU1NLHFCQUFxQjtRQUNsRGI7UUFDQWMsYUFBYVAsTUFBTU8sV0FBVztRQUM5QkMsZUFBZVIsTUFBTVEsYUFBYTtRQUNsQ0MsV0FBV1QsTUFBTVMsU0FBUztRQUMxQmtCLGtCQUFrQjlCLFlBQVlQO1FBQzlCc0IscUJBQXFCWixNQUFNWSxtQkFBbUI7SUFDaEQ7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2hvb2tzL3VzZUNvbnRyYWN0LnRzPzRmMzIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUFjY291bnQsIHVzZVB1YmxpY0NsaWVudCwgdXNlV2FsbGV0Q2xpZW50LCB1c2VDaGFpbklkLCB1c2VDb25uZWN0IH0gZnJvbSAnd2FnbWknO1xuaW1wb3J0IHsgZ2V0Q29udHJhY3QgfSBmcm9tICd2aWVtJztcbmltcG9ydCBFeGFtTWFuYWdlbWVudEFCSSBmcm9tICcuLi9jb250cmFjdHMvRXhhbU1hbmFnZW1lbnQuanNvbic7XG5pbXBvcnQgQ2VydGlmaWNhdGVzQUJJIGZyb20gJy4uL2NvbnRyYWN0cy9DZXJ0aWZpY2F0ZXMuanNvbic7XG5pbXBvcnQgRXhhbWluYXRpb25zQUJJIGZyb20gJy4uL2NvbnRyYWN0cy9FeGFtaW5hdGlvbnMuanNvbic7XG5pbXBvcnQgSWRlbnRpdHlBQkkgZnJvbSAnLi4vY29udHJhY3RzL0lkZW50aXR5Lmpzb24nO1xuaW1wb3J0IFNlY3VyaXR5VXRpbHNBQkkgZnJvbSAnLi4vY29udHJhY3RzL1NlY3VyaXR5VXRpbHMuanNvbic7XG5pbXBvcnQgeyB1c2VUb2FzdCB9IGZyb20gJ0BjaGFrcmEtdWkvcmVhY3QnO1xuXG5jb25zdCBFWEFNX01BTkFHRU1FTlRfQUREUkVTUyA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0VYQU1fTUFOQUdFTUVOVF9DT05UUkFDVF9BRERSRVNTIHx8ICcnO1xuY29uc3QgQ0VSVElGSUNBVEVTX0FERFJFU1MgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19DRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUyB8fCAnJztcbmNvbnN0IEVYQU1JTkFUSU9OU19BRERSRVNTID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRVhBTUlOQVRJT05TX0NPTlRSQUNUX0FERFJFU1MgfHwgJyc7XG5jb25zdCBJREVOVElUWV9BRERSRVNTID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyB8fCAnJztcbmNvbnN0IFNFQ1VSSVRZX1VUSUxTX0FERFJFU1MgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TRUNVUklUWV9VVElMU19DT05UUkFDVF9BRERSRVNTIHx8ICcnO1xuY29uc3QgVEFSR0VUX0NIQUlOX0lEID0gMTMzNzsgLy8gTG9jYWwgbmV0d29yayBjaGFpbiBJRFxuXG5pbnRlcmZhY2UgRXhhbU1hbmFnZW1lbnRDb250cmFjdCB7XG4gIGlzSW5zdGl0dXRpb246IChhZGRyZXNzOiBzdHJpbmcpID0+IFByb21pc2U8Ym9vbGVhbj47XG4gIGdldEluc3RpdHV0aW9uOiAoYWRkcmVzczogc3RyaW5nKSA9PiBQcm9taXNlPGFueT47XG4gIGdldEluc3RpdHV0aW9uRXhhbXM6IChhZGRyZXNzOiBzdHJpbmcpID0+IFByb21pc2U8YW55W10+O1xuICBnZXRFeGFtUmVzdWx0czogKGV4YW1JZDogc3RyaW5nKSA9PiBQcm9taXNlPGFueVtdPjtcbiAgcHJvdmlkZXI/OiBhbnk7XG4gIHJ1bm5lcj86IGFueTtcbiAgd3JpdGU6IHtcbiAgICB1cGRhdGVJbnN0aXR1dGlvblByb2ZpbGU6IChwYXJhbXM6IHtcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAgbmFtZTogc3RyaW5nLFxuICAgICAgICBtaW5pc3RyeTogc3RyaW5nLFxuICAgICAgICB1bml2ZXJzaXR5OiBzdHJpbmcsXG4gICAgICAgIGNvbGxlZ2U6IHN0cmluZyxcbiAgICAgICAgZGVzY3JpcHRpb246IHN0cmluZyxcbiAgICAgICAgbG9nbzogc3RyaW5nLFxuICAgICAgICB3ZWJzaXRlOiBzdHJpbmcsXG4gICAgICAgIGVtYWlsOiBzdHJpbmcsXG4gICAgICAgIHBob25lOiBzdHJpbmdcbiAgICAgIF1cbiAgICB9KSA9PiBQcm9taXNlPHsgd2FpdDogKCkgPT4gUHJvbWlzZTx2b2lkPiB9PjtcbiAgICBzdWJtaXRFeGFtUmVzdWx0czogKHBhcmFtczoge1xuICAgICAgYXJnczogW2V4YW1JZDogc3RyaW5nLCByZXN1bHRzOiBhbnlbXV0sXG4gICAgICBjaGFpbklkPzogbnVtYmVyXG4gICAgfSkgPT4gUHJvbWlzZTx7IHdhaXQ6ICgpID0+IFByb21pc2U8dm9pZD4gfT47XG4gICAgcmVnaXN0ZXJTdHVkZW50czogKHBhcmFtczoge1xuICAgICAgYXJnczogW2V4YW1JZDogc3RyaW5nLCBzdHVkZW50czogc3RyaW5nW11dLFxuICAgICAgY2hhaW5JZD86IG51bWJlclxuICAgIH0pID0+IFByb21pc2U8eyB3YWl0OiAoKSA9PiBQcm9taXNlPHZvaWQ+IH0+O1xuICAgIHVwZGF0ZUV4YW1TdGF0dXM6IChwYXJhbXM6IHtcbiAgICAgIGFyZ3M6IFtleGFtSWQ6IHN0cmluZywgc3RhdHVzOiBzdHJpbmddLFxuICAgICAgY2hhaW5JZD86IG51bWJlclxuICAgIH0pID0+IFByb21pc2U8eyB3YWl0OiAoKSA9PiBQcm9taXNlPHZvaWQ+IH0+O1xuICAgIGNyZWF0ZUV4YW06IChwYXJhbXM6IHtcbiAgICAgIGFyZ3M6IFt0aXRsZTogc3RyaW5nLCBkZXNjcmlwdGlvbjogc3RyaW5nLCBkYXRlOiBudW1iZXJdLFxuICAgICAgY2hhaW5JZD86IG51bWJlclxuICAgIH0pID0+IFByb21pc2U8eyB3YWl0OiAoKSA9PiBQcm9taXNlPHZvaWQ+IH0+O1xuICAgIGlzc3VlQ2VydGlmaWNhdGU6IChwYXJhbXM6IHtcbiAgICAgIGFyZ3M6IFtzdHVkZW50OiBzdHJpbmcsIHRpdGxlOiBzdHJpbmcsIGRlc2NyaXB0aW9uOiBzdHJpbmddLFxuICAgICAgY2hhaW5JZD86IG51bWJlclxuICAgIH0pID0+IFByb21pc2U8eyB3YWl0OiAoKSA9PiBQcm9taXNlPHZvaWQ+IH0+O1xuICB9O1xufVxuXG5pbnRlcmZhY2UgQ2VydGlmaWNhdGVzQ29udHJhY3Qge1xuICBnZXRJbnN0aXR1dGlvbkNlcnRpZmljYXRlczogKGFkZHJlc3M6IHN0cmluZykgPT4gUHJvbWlzZTxhbnlbXT47XG4gIHdyaXRlOiB7XG4gICAgaXNzdWVDZXJ0aWZpY2F0ZTogKHBhcmFtczoge1xuICAgICAgYXJnczogW3N0dWRlbnRBZGRyZXNzOiBzdHJpbmcsIHRpdGxlOiBzdHJpbmcsIGRlc2NyaXB0aW9uOiBzdHJpbmddLFxuICAgICAgY2hhaW5JZD86IG51bWJlclxuICAgIH0pID0+IFByb21pc2U8eyB3YWl0OiAoKSA9PiBQcm9taXNlPHZvaWQ+IH0+O1xuICB9O1xufVxuXG5pbnRlcmZhY2UgRXhhbWluYXRpb25zQ29udHJhY3Qge1xuICAvLyBBZGQgZXhhbWluYXRpb24gY29udHJhY3QgbWV0aG9kcyBoZXJlXG4gIHdyaXRlOiB7XG4gICAgY3JlYXRlRXhhbWluYXRpb246IChwYXJhbXM6IHtcbiAgICAgIGFyZ3M6IFtpcGZzSGFzaDogc3RyaW5nLCBzdGFydFRpbWU6IG51bWJlciwgZW5kVGltZTogbnVtYmVyXSxcbiAgICAgIGNoYWluSWQ/OiBudW1iZXJcbiAgICB9KSA9PiBQcm9taXNlPHsgd2FpdDogKCkgPT4gUHJvbWlzZTx2b2lkPiB9PjtcbiAgICByZWdpc3RlckZvckV4YW06IChwYXJhbXM6IHtcbiAgICAgIGFyZ3M6IFtleGFtSWQ6IHN0cmluZ10sXG4gICAgICBjaGFpbklkPzogbnVtYmVyXG4gICAgfSkgPT4gUHJvbWlzZTx7IHdhaXQ6ICgpID0+IFByb21pc2U8dm9pZD4gfT47XG4gIH07XG59XG5cbmludGVyZmFjZSBJZGVudGl0eUNvbnRyYWN0IHtcbiAgLy8gQWRkIGlkZW50aXR5IGNvbnRyYWN0IG1ldGhvZHMgaGVyZVxuICB3cml0ZToge1xuICAgIHJlZ2lzdGVySWRlbnRpdHk6IChwYXJhbXM6IHtcbiAgICAgIGFyZ3M6IFtuYW1lOiBzdHJpbmcsIGVtYWlsOiBzdHJpbmddLFxuICAgICAgY2hhaW5JZD86IG51bWJlclxuICAgIH0pID0+IFByb21pc2U8eyB3YWl0OiAoKSA9PiBQcm9taXNlPHZvaWQ+IH0+O1xuICB9O1xufVxuXG5pbnRlcmZhY2UgU2VjdXJpdHlVdGlsc0NvbnRyYWN0IHtcbiAgLy8gQWRkIHNlY3VyaXR5IHV0aWxzIGNvbnRyYWN0IG1ldGhvZHMgaGVyZVxuICB3cml0ZToge1xuICAgIHZlcmlmeUhhc2g6IChwYXJhbXM6IHtcbiAgICAgIGFyZ3M6IFtoYXNoOiBzdHJpbmcsIHNpZ25hdHVyZTogc3RyaW5nXSxcbiAgICAgIGNoYWluSWQ/OiBudW1iZXJcbiAgICB9KSA9PiBQcm9taXNlPHsgd2FpdDogKCkgPT4gUHJvbWlzZTx2b2lkPiB9PjtcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IHVzZUNvbnRyYWN0ID0gKCkgPT4ge1xuICBjb25zdCB7IGFkZHJlc3M6IGFjY291bnQgfSA9IHVzZUFjY291bnQoKTtcbiAgY29uc3QgcHVibGljQ2xpZW50ID0gdXNlUHVibGljQ2xpZW50KCk7XG4gIGNvbnN0IHsgZGF0YTogd2FsbGV0Q2xpZW50IH0gPSB1c2VXYWxsZXRDbGllbnQoKTtcbiAgY29uc3QgY2hhaW5JZCA9IHVzZUNoYWluSWQoKTtcbiAgY29uc3QgeyBjb25uZWN0IH0gPSB1c2VDb25uZWN0KCk7XG4gIGNvbnN0IHRvYXN0ID0gdXNlVG9hc3QoKTtcbiAgXG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGUoe1xuICAgIGV4YW1NYW5hZ2VtZW50Q29udHJhY3Q6IG51bGwgYXMgRXhhbU1hbmFnZW1lbnRDb250cmFjdCB8IG51bGwsXG4gICAgY2VydGlmaWNhdGVzQ29udHJhY3Q6IG51bGwgYXMgQ2VydGlmaWNhdGVzQ29udHJhY3QgfCBudWxsLFxuICAgIGV4YW1pbmF0aW9uc0NvbnRyYWN0OiBudWxsIGFzIEV4YW1pbmF0aW9uc0NvbnRyYWN0IHwgbnVsbCxcbiAgICBpZGVudGl0eUNvbnRyYWN0OiBudWxsIGFzIElkZW50aXR5Q29udHJhY3QgfCBudWxsLFxuICAgIHNlY3VyaXR5VXRpbHNDb250cmFjdDogbnVsbCBhcyBTZWN1cml0eVV0aWxzQ29udHJhY3QgfCBudWxsLFxuICAgIGlzQ29ubmVjdGVkOiBmYWxzZSxcbiAgICBpc0luaXRpYWxpemVkOiBmYWxzZSxcbiAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgIG5ldHdvcmtTd2l0Y2hBdHRlbXB0ZWQ6IGZhbHNlLFxuICAgIGluaXRpYWxpemF0aW9uQXR0ZW1wdGVkOiBmYWxzZSxcbiAgICBpbml0aWFsaXphdGlvbkVycm9yOiBudWxsIGFzIHN0cmluZyB8IG51bGxcbiAgfSk7XG5cbiAgLy8gU2luZ2xlIGVmZmVjdCB0byBoYW5kbGUgYm90aCBuZXR3b3JrIHZhbGlkYXRpb24gYW5kIGNvbnRyYWN0IGluaXRpYWxpemF0aW9uXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGlzTW91bnRlZCA9IHRydWU7XG4gICAgbGV0IHN3aXRjaEF0dGVtcHRzID0gMDtcbiAgICBjb25zdCBNQVhfU1dJVENIX0FUVEVNUFRTID0gMztcblxuICAgIGNvbnN0IHZlcmlmeU5ldHdvcmsgPSBhc3luYyAoZXhwZWN0ZWRDaGFpbklkOiBudW1iZXIpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghcHVibGljQ2xpZW50KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignUHVibGljIGNsaWVudCBub3QgYXZhaWxhYmxlJyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGFpbklkID0gYXdhaXQgcHVibGljQ2xpZW50LmdldENoYWluSWQoKTtcbiAgICAgICAgY29uc29sZS5sb2coYFZlcmlmeWluZyBuZXR3b3JrIC0gQ3VycmVudDogJHtjdXJyZW50Q2hhaW5JZH0sIEV4cGVjdGVkOiAke2V4cGVjdGVkQ2hhaW5JZH1gKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRDaGFpbklkID09PSBleHBlY3RlZENoYWluSWQ7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdOZXR3b3JrIHZlcmlmaWNhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgd2FpdEZvck5ldHdvcmtTd2l0Y2ggPSBhc3luYyAoZXhwZWN0ZWRDaGFpbklkOiBudW1iZXIpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICAgIGNvbnN0IG1heEF0dGVtcHRzID0gMzA7IC8vIEluY3JlYXNlIG1heCBhdHRlbXB0cyB0byAzMCAoMTUgc2Vjb25kcyB0b3RhbClcbiAgICAgIGNvbnN0IGludGVydmFsID0gNTAwOyAvLyBDaGVjayBldmVyeSA1MDBtc1xuICAgICAgbGV0IGF0dGVtcHRzID0gMDtcblxuICAgICAgd2hpbGUgKGF0dGVtcHRzIDwgbWF4QXR0ZW1wdHMpIHtcbiAgICAgICAgY29uc3QgaXNDb3JyZWN0TmV0d29yayA9IGF3YWl0IHZlcmlmeU5ldHdvcmsoZXhwZWN0ZWRDaGFpbklkKTtcbiAgICAgICAgaWYgKGlzQ29ycmVjdE5ldHdvcmspIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnTmV0d29yayBzd2l0Y2ggdmVyaWZpZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGludGVydmFsKSk7XG4gICAgICAgIGF0dGVtcHRzKys7XG4gICAgICAgIGNvbnNvbGUubG9nKGBXYWl0aW5nIGZvciBuZXR3b3JrIHN3aXRjaC4uLiBBdHRlbXB0ICR7YXR0ZW1wdHN9LyR7bWF4QXR0ZW1wdHN9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUuZXJyb3IoJ9iq2KzYp9mI2LIg2KfZhNit2K8g2KfZhNij2YLYtdmJINmE2YXYrdin2YjZhNin2Kog2KfZhNiq2K3ZgtmCINmF2YYg2KrYqNiv2YrZhCDYp9mE2LTYqNmD2KkgfCBNYXhpbXVtIG5ldHdvcmsgc3dpdGNoIHZlcmlmaWNhdGlvbiBhdHRlbXB0cyBleGNlZWRlZCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBjb25zdCBzd2l0Y2hOZXR3b3JrID0gYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgaWYgKCF3aW5kb3cuZXRoZXJldW0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhTWFzayDYutmK2LEg2YXYq9io2KogfCBNZXRhTWFzayBpcyBub3QgaW5zdGFsbGVkJyk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIHRvIHN3aXRjaCBuZXR3b3JrLi4uJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBGaXJzdCB0cnkgdG8gc3dpdGNoXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgd2luZG93LmV0aGVyZXVtLnJlcXVlc3Qoe1xuICAgICAgICAgICAgbWV0aG9kOiAnd2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW4nLFxuICAgICAgICAgICAgcGFyYW1zOiBbeyBjaGFpbklkOiBgMHgke1RBUkdFVF9DSEFJTl9JRC50b1N0cmluZygxNil9YCB9XVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChzd2l0Y2hFcnJvcjogYW55KSB7XG4gICAgICAgICAgLy8gSWYgbmV0d29yayBkb2Vzbid0IGV4aXN0LCBhZGQgaXRcbiAgICAgICAgICBpZiAoc3dpdGNoRXJyb3IuY29kZSA9PT0gNDkwMikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ05ldHdvcmsgbm90IGZvdW5kLCBhZGRpbmcuLi4nKTtcbiAgICAgICAgICAgIGF3YWl0IHdpbmRvdy5ldGhlcmV1bS5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgbWV0aG9kOiAnd2FsbGV0X2FkZEV0aGVyZXVtQ2hhaW4nLFxuICAgICAgICAgICAgICBwYXJhbXM6IFt7XG4gICAgICAgICAgICAgICAgY2hhaW5JZDogYDB4JHtUQVJHRVRfQ0hBSU5fSUQudG9TdHJpbmcoMTYpfWAsXG4gICAgICAgICAgICAgICAgY2hhaW5OYW1lOiAnR2FuYWNoZSBMb2NhbCcsXG4gICAgICAgICAgICAgICAgcnBjVXJsczogWydodHRwOi8vMTI3LjAuMC4xOjc1NDUnXSxcbiAgICAgICAgICAgICAgICBuYXRpdmVDdXJyZW5jeToge1xuICAgICAgICAgICAgICAgICAgbmFtZTogJ0VUSCcsXG4gICAgICAgICAgICAgICAgICBzeW1ib2w6ICdFVEgnLFxuICAgICAgICAgICAgICAgICAgZGVjaW1hbHM6IDE4XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHN3aXRjaEVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdhaXQgZm9yIG5ldHdvcmsgc3dpdGNoIHRvIGNvbXBsZXRlXG4gICAgICAgIGNvbnNvbGUubG9nKCdXYWl0aW5nIGZvciBuZXR3b3JrIHN3aXRjaCB0byBjb21wbGV0ZS4uLicpO1xuICAgICAgICBhd2FpdCB3YWl0Rm9yTmV0d29ya1N3aXRjaChUQVJHRVRfQ0hBSU5fSUQpO1xuICAgICAgICBjb25zb2xlLmxvZygnTmV0d29yayBzd2l0Y2ggY29tcGxldGVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignTmV0d29yayBzd2l0Y2ggZmFpbGVkOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGluaXRpYWxpemVDb250cmFjdHMgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIWlzTW91bnRlZCB8fCAhcHVibGljQ2xpZW50KSByZXR1cm47XG5cbiAgICAgIC8vIFJlc2V0IHN0YXRlIGF0IHRoZSBzdGFydCBvZiBpbml0aWFsaXphdGlvblxuICAgICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBleGFtTWFuYWdlbWVudENvbnRyYWN0OiBudWxsLFxuICAgICAgICBjZXJ0aWZpY2F0ZXNDb250cmFjdDogbnVsbCxcbiAgICAgICAgaXNJbml0aWFsaXplZDogZmFsc2UsXG4gICAgICAgIGlzTG9hZGluZzogdHJ1ZSxcbiAgICAgICAgaW5pdGlhbGl6YXRpb25FcnJvcjogbnVsbFxuICAgICAgfSkpO1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyAxLiBWYWxpZGF0ZSBkZXBlbmRlbmNpZXNcbiAgICAgICAgaWYgKCFhY2NvdW50IHx8ICF3YWxsZXRDbGllbnQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ29yZSBkZXBlbmRlbmNpZXMgbm90IHJlYWR5OicsIHtcbiAgICAgICAgICAgIGhhc0FjY291bnQ6ICEhYWNjb3VudCxcbiAgICAgICAgICAgIGhhc1dhbGxldENsaWVudDogISF3YWxsZXRDbGllbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ9mK2LHYrNmJINin2YTYp9mG2KrYuNin2LEg2K3YqtmJINmK2KrZhSDYqtit2YXZitmEINis2YXZiti5INin2YTZhdiq2LfZhNio2KfYqiB8IFdhaXRpbmcgZm9yIGRlcGVuZGVuY2llcyB0byBsb2FkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUVYQU1fTUFOQUdFTUVOVF9BRERSRVNTIHx8ICFDRVJUSUZJQ0FURVNfQUREUkVTUykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NvbnRyYWN0IGFkZHJlc3NlcyBtaXNzaW5nOicsIHtcbiAgICAgICAgICAgIEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTLFxuICAgICAgICAgICAgQ0VSVElGSUNBVEVTX0FERFJFU1NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ9i52YbYp9mI2YrZhiDYp9mE2LnZgtmI2K8g2LrZitixINmF2YPZiNmG2KkgfCBDb250cmFjdCBhZGRyZXNzZXMgbm90IGNvbmZpZ3VyZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDIuIE5ldHdvcmsgdmFsaWRhdGlvbiB3aXRoIHJldHJpZXNcbiAgICAgICAgY29uc3QgaXNDb3JyZWN0TmV0d29yayA9IGF3YWl0IHZlcmlmeU5ldHdvcmsoVEFSR0VUX0NIQUlOX0lEKTtcbiAgICAgICAgaWYgKCFpc0NvcnJlY3ROZXR3b3JrKSB7XG4gICAgICAgICAgaWYgKHN3aXRjaEF0dGVtcHRzID49IE1BWF9TV0lUQ0hfQVRURU1QVFMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcign2KrYrNin2YjYsiDYp9mE2K3YryDYp9mE2KPZgti12Ykg2YTZhdit2KfZiNmE2KfYqiDYqtio2K/ZitmEINin2YTYtNio2YPYqSB8IE1heGltdW0gbmV0d29yayBzd2l0Y2ggYXR0ZW1wdHMgZXhjZWVkZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgc3dpdGNoQXR0ZW1wdHMrKztcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQXR0ZW1wdGluZyBuZXR3b3JrIHN3aXRjaCAoJHtzd2l0Y2hBdHRlbXB0c30vJHtNQVhfU1dJVENIX0FUVEVNUFRTfSkuLi5gKTtcbiAgICAgICAgICBhd2FpdCBzd2l0Y2hOZXR3b3JrKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgZmluYWxDaGVjayA9IGF3YWl0IHZlcmlmeU5ldHdvcmsoVEFSR0VUX0NIQUlOX0lEKTtcbiAgICAgICAgICBpZiAoIWZpbmFsQ2hlY2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcign2YHYtNmEINmB2Yog2KfZhNiq2K3ZgtmCINin2YTZhtmH2KfYptmKINmF2YYg2KfZhNi02KjZg9ipIHwgRmluYWwgbmV0d29yayB2ZXJpZmljYXRpb24gZmFpbGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gQ29udHJhY3QgZGVwbG95bWVudCB2ZXJpZmljYXRpb25cbiAgICAgICAgY29uc29sZS5sb2coJ1ZlcmlmeWluZyBjb250cmFjdCBkZXBsb3ltZW50cy4uLicpO1xuICAgICAgICBjb25zdCBbZXhhbUNvZGUsIGNlcnRDb2RlXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICBwdWJsaWNDbGllbnQuZ2V0Qnl0ZWNvZGUoeyBhZGRyZXNzOiBFWEFNX01BTkFHRU1FTlRfQUREUkVTUyBhcyBgMHgke3N0cmluZ31gIH0pLFxuICAgICAgICAgIHB1YmxpY0NsaWVudC5nZXRCeXRlY29kZSh7IGFkZHJlc3M6IENFUlRJRklDQVRFU19BRERSRVNTIGFzIGAweCR7c3RyaW5nfWAgfSlcbiAgICAgICAgXSk7XG5cbiAgICAgICAgaWYgKCFleGFtQ29kZSB8fCBleGFtQ29kZSA9PT0gJzB4Jykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcign2LnZgtivINil2K/Yp9ix2Kkg2KfZhNin2K7Yqtio2KfYsdin2Kog2LrZitixINmF2YjYrNmI2K8gfCBFeGFtIE1hbmFnZW1lbnQgY29udHJhY3Qgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNlcnRDb2RlIHx8IGNlcnRDb2RlID09PSAnMHgnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCfYudmC2K8g2KfZhNi02YfYp9iv2KfYqiDYutmK2LEg2YXZiNis2YjYryB8IENlcnRpZmljYXRlcyBjb250cmFjdCBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDQuIENvbnRyYWN0IGluaXRpYWxpemF0aW9uXG4gICAgICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyBjb250cmFjdCBpbnN0YW5jZXMuLi4nKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSByZWFkLW9ubHkgY29udHJhY3QgaW5zdGFuY2VzXG4gICAgICAgIGNvbnN0IGV4YW1NYW5hZ2VtZW50UmVhZCA9IGdldENvbnRyYWN0KHtcbiAgICAgICAgICBhZGRyZXNzOiBFWEFNX01BTkFHRU1FTlRfQUREUkVTUyBhcyBgMHgke3N0cmluZ31gLFxuICAgICAgICAgIGFiaTogRXhhbU1hbmFnZW1lbnRBQkkuYWJpLFxuICAgICAgICAgIGNsaWVudDogcHVibGljQ2xpZW50XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGNlcnRpZmljYXRlc1JlYWQgPSBnZXRDb250cmFjdCh7XG4gICAgICAgICAgYWRkcmVzczogQ0VSVElGSUNBVEVTX0FERFJFU1MgYXMgYDB4JHtzdHJpbmd9YCxcbiAgICAgICAgICBhYmk6IENlcnRpZmljYXRlc0FCSS5hYmksXG4gICAgICAgICAgY2xpZW50OiBwdWJsaWNDbGllbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHdyaXRlLWVuYWJsZWQgY29udHJhY3QgaW5zdGFuY2VzXG4gICAgICAgIGNvbnN0IGV4YW1NYW5hZ2VtZW50V3JpdGUgPSB3YWxsZXRDbGllbnQgPyBnZXRDb250cmFjdCh7XG4gICAgICAgICAgYWRkcmVzczogRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MgYXMgYDB4JHtzdHJpbmd9YCxcbiAgICAgICAgICBhYmk6IEV4YW1NYW5hZ2VtZW50QUJJLmFiaSxcbiAgICAgICAgICBjbGllbnQ6IHdhbGxldENsaWVudFxuICAgICAgICB9KSA6IG51bGw7XG5cbiAgICAgICAgY29uc3QgY2VydGlmaWNhdGVzV3JpdGUgPSB3YWxsZXRDbGllbnQgPyBnZXRDb250cmFjdCh7XG4gICAgICAgICAgYWRkcmVzczogQ0VSVElGSUNBVEVTX0FERFJFU1MgYXMgYDB4JHtzdHJpbmd9YCxcbiAgICAgICAgICBhYmk6IENlcnRpZmljYXRlc0FCSS5hYmksXG4gICAgICAgICAgY2xpZW50OiB3YWxsZXRDbGllbnRcbiAgICAgICAgfSkgOiBudWxsO1xuXG4gICAgICAgIGlmICghZXhhbU1hbmFnZW1lbnRSZWFkIHx8ICFjZXJ0aWZpY2F0ZXNSZWFkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCfZgdi02YQg2YHZiiDYpdmG2LTYp9ihINi52YLZiNivINin2YTZgtix2KfYodipIHwgRmFpbGVkIHRvIGNyZWF0ZSByZWFkIGNvbnRyYWN0IGluc3RhbmNlcycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFleGFtTWFuYWdlbWVudFdyaXRlIHx8ICFjZXJ0aWZpY2F0ZXNXcml0ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcign2YHYtNmEINmB2Yog2KXZhti02KfYoSDYudmC2YjYryDYp9mE2YPYqtin2KjYqSB8IEZhaWxlZCB0byBjcmVhdGUgd3JpdGUgY29udHJhY3QgaW5zdGFuY2VzJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyA1LiBDb250cmFjdCB0ZXN0aW5nXG4gICAgICAgIGNvbnNvbGUubG9nKCdUZXN0aW5nIGNvbnRyYWN0IGNvbm5lY3Rpb25zLi4uJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgW2lzSW5zdGl0dXRpb25SZXN1bHQsIGNlcnRpZmljYXRlc1Jlc3VsdF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBleGFtTWFuYWdlbWVudFJlYWQucmVhZC5pc0luc3RpdHV0aW9uKFthY2NvdW50XSksXG4gICAgICAgICAgICBjZXJ0aWZpY2F0ZXNSZWFkLnJlYWQuZ2V0SW5zdGl0dXRpb25DZXJ0aWZpY2F0ZXMoW2FjY291bnRdKVxuICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBpc0luc3RpdHV0aW9uUmVzdWx0ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgY2VydGlmaWNhdGVzUmVzdWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCfZgdi02YQg2YHZiiDZgtix2KfYodipINio2YrYp9mG2KfYqiDYp9mE2LnZgtmI2K8gfCBGYWlsZWQgdG8gcmVhZCBjb250cmFjdCBkYXRhJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc29sZS5sb2coJ0NvbnRyYWN0IHRlc3RzIHN1Y2Nlc3NmdWwnKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdDb250cmFjdCB0ZXN0IGZhaWxlZDonLCBlcnJvcik7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCfZgdi02YQg2YHZiiDYp9mE2KfYqti12KfZhCDYqNin2YTYudmC2YjYryB8IENvbnRyYWN0IGNvbm5lY3Rpb24gdGVzdCBmYWlsZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDYuIFVwZGF0ZSBzdGF0ZSB3aXRoIGluaXRpYWxpemVkIGNvbnRyYWN0c1xuICAgICAgICBpZiAoaXNNb3VudGVkKSB7XG4gICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgICAgICAgICBleGFtTWFuYWdlbWVudENvbnRyYWN0OiB7XG4gICAgICAgICAgICAgIGlzSW5zdGl0dXRpb246IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGFtTWFuYWdlbWVudFJlYWQucmVhZC5pc0luc3RpdHV0aW9uKFthZGRyZXNzXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZ2V0SW5zdGl0dXRpb246IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgZXhhbU1hbmFnZW1lbnRSZWFkLnJlYWQuZ2V0SW5zdGl0dXRpb24oW2FkZHJlc3NdKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZ2V0SW5zdGl0dXRpb25FeGFtczogYXN5bmMgKGFkZHJlc3M6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBleGFtTWFuYWdlbWVudFJlYWQucmVhZC5nZXRJbnN0aXR1dGlvbkV4YW1zKFthZGRyZXNzXSkgPz8gW107XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGdldEV4YW1SZXN1bHRzOiBhc3luYyAoZXhhbUlkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgZXhhbU1hbmFnZW1lbnRSZWFkLnJlYWQuZ2V0RXhhbVJlc3VsdHMoW2V4YW1JZF0pID8/IFtdO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB3cml0ZToge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUluc3RpdHV0aW9uUHJvZmlsZTogYXN5bmMgKHBhcmFtczogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWV4YW1NYW5hZ2VtZW50V3JpdGUpIHRocm93IG5ldyBFcnJvcign2LnZgtivINin2YTZg9iq2KfYqNipINi62YrYsSDZhdiq2YjZgdixIHwgV3JpdGUgY29udHJhY3Qgbm90IGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IGV4YW1NYW5hZ2VtZW50V3JpdGUud3JpdGUudXBkYXRlSW5zdGl0dXRpb25Qcm9maWxlKHBhcmFtcy5hcmdzKTtcbiAgICAgICAgICAgICAgICAgIGlmICghaGFzaCkgdGhyb3cgbmV3IEVycm9yKCfZgdi02YQg2YHZiiDYqtit2K/ZitirINin2YTZhdmE2YEg2KfZhNi02K7YtdmKIHwgRmFpbGVkIHRvIHVwZGF0ZSBpbnN0aXR1dGlvbiBwcm9maWxlJyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4geyB3YWl0OiBhc3luYyAoKSA9PiB7IGF3YWl0IHB1YmxpY0NsaWVudC53YWl0Rm9yVHJhbnNhY3Rpb25SZWNlaXB0KHsgaGFzaCB9KTsgfSB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3VibWl0RXhhbVJlc3VsdHM6IGFzeW5jIChwYXJhbXM6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKCFleGFtTWFuYWdlbWVudFdyaXRlKSB0aHJvdyBuZXcgRXJyb3IoJ9i52YLYryDYp9mE2YPYqtin2KjYqSDYutmK2LEg2YXYqtmI2YHYsSB8IFdyaXRlIGNvbnRyYWN0IG5vdCBhdmFpbGFibGUnKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBleGFtTWFuYWdlbWVudFdyaXRlLndyaXRlLnN1Ym1pdEV4YW1SZXN1bHRzKHBhcmFtcy5hcmdzKTtcbiAgICAgICAgICAgICAgICAgIGlmICghaGFzaCkgdGhyb3cgbmV3IEVycm9yKCfZgdi02YQg2YHZiiDYpdix2LPYp9mEINin2YTZhtiq2KfYptisIHwgRmFpbGVkIHRvIHN1Ym1pdCBleGFtIHJlc3VsdHMnKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7IHdhaXQ6IGFzeW5jICgpID0+IHsgYXdhaXQgcHVibGljQ2xpZW50LndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQoeyBoYXNoIH0pOyB9IH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZWdpc3RlclN0dWRlbnRzOiBhc3luYyAocGFyYW1zOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmICghZXhhbU1hbmFnZW1lbnRXcml0ZSkgdGhyb3cgbmV3IEVycm9yKCfYudmC2K8g2KfZhNmD2KrYp9io2Kkg2LrZitixINmF2KrZiNmB2LEgfCBXcml0ZSBjb250cmFjdCBub3QgYXZhaWxhYmxlJyk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBoYXNoID0gYXdhaXQgZXhhbU1hbmFnZW1lbnRXcml0ZS53cml0ZS5yZWdpc3RlclN0dWRlbnRzKHBhcmFtcy5hcmdzKTtcbiAgICAgICAgICAgICAgICAgIGlmICghaGFzaCkgdGhyb3cgbmV3IEVycm9yKCfZgdi02YQg2YHZiiDYqtiz2KzZitmEINin2YTYt9mE2KfYqCB8IEZhaWxlZCB0byByZWdpc3RlciBzdHVkZW50cycpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgd2FpdDogYXN5bmMgKCkgPT4geyBhd2FpdCBwdWJsaWNDbGllbnQud2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdCh7IGhhc2ggfSk7IH0gfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHVwZGF0ZUV4YW1TdGF0dXM6IGFzeW5jIChwYXJhbXM6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKCFleGFtTWFuYWdlbWVudFdyaXRlKSB0aHJvdyBuZXcgRXJyb3IoJ9i52YLYryDYp9mE2YPYqtin2KjYqSDYutmK2LEg2YXYqtmI2YHYsSB8IFdyaXRlIGNvbnRyYWN0IG5vdCBhdmFpbGFibGUnKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBleGFtTWFuYWdlbWVudFdyaXRlLndyaXRlLnVwZGF0ZUV4YW1TdGF0dXMocGFyYW1zLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgaWYgKCFoYXNoKSB0aHJvdyBuZXcgRXJyb3IoJ9mB2LTZhCDZgdmKINiq2K3Yr9mK2Ksg2K3Yp9mE2Kkg2KfZhNin2K7Yqtio2KfYsSB8IEZhaWxlZCB0byB1cGRhdGUgZXhhbSBzdGF0dXMnKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7IHdhaXQ6IGFzeW5jICgpID0+IHsgYXdhaXQgcHVibGljQ2xpZW50LndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQoeyBoYXNoIH0pOyB9IH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFeGFtOiBhc3luYyAocGFyYW1zOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmICghZXhhbU1hbmFnZW1lbnRXcml0ZSkgdGhyb3cgbmV3IEVycm9yKCfYudmC2K8g2KfZhNmD2KrYp9io2Kkg2LrZitixINmF2KrZiNmB2LEgfCBXcml0ZSBjb250cmFjdCBub3QgYXZhaWxhYmxlJyk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBoYXNoID0gYXdhaXQgZXhhbU1hbmFnZW1lbnRXcml0ZS53cml0ZS5jcmVhdGVFeGFtKHBhcmFtcy5hcmdzKTtcbiAgICAgICAgICAgICAgICAgIGlmICghaGFzaCkgdGhyb3cgbmV3IEVycm9yKCfZgdi02YQg2YHZiiDYpdmG2LTYp9ihINin2YTYp9iu2KrYqNin2LEgfCBGYWlsZWQgdG8gY3JlYXRlIGV4YW0nKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7IHdhaXQ6IGFzeW5jICgpID0+IHsgYXdhaXQgcHVibGljQ2xpZW50LndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQoeyBoYXNoIH0pOyB9IH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc3N1ZUNlcnRpZmljYXRlOiBhc3luYyAocGFyYW1zOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmICghZXhhbU1hbmFnZW1lbnRXcml0ZSkgdGhyb3cgbmV3IEVycm9yKCfYudmC2K8g2KfZhNmD2KrYp9io2Kkg2LrZitixINmF2KrZiNmB2LEgfCBXcml0ZSBjb250cmFjdCBub3QgYXZhaWxhYmxlJyk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBoYXNoID0gYXdhaXQgZXhhbU1hbmFnZW1lbnRXcml0ZS53cml0ZS5pc3N1ZUNlcnRpZmljYXRlKHBhcmFtcy5hcmdzKTtcbiAgICAgICAgICAgICAgICAgIGlmICghaGFzaCkgdGhyb3cgbmV3IEVycm9yKCfZgdi02YQg2YHZiiDYpdi12K/Yp9ixINin2YTYtNmH2KfYr9ipIHwgRmFpbGVkIHRvIGlzc3VlIGNlcnRpZmljYXRlJyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4geyB3YWl0OiBhc3luYyAoKSA9PiB7IGF3YWl0IHB1YmxpY0NsaWVudC53YWl0Rm9yVHJhbnNhY3Rpb25SZWNlaXB0KHsgaGFzaCB9KTsgfSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBhcyBFeGFtTWFuYWdlbWVudENvbnRyYWN0LFxuICAgICAgICAgICAgY2VydGlmaWNhdGVzQ29udHJhY3Q6IHtcbiAgICAgICAgICAgICAgZ2V0SW5zdGl0dXRpb25DZXJ0aWZpY2F0ZXM6IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgY2VydGlmaWNhdGVzUmVhZC5yZWFkLmdldEluc3RpdHV0aW9uQ2VydGlmaWNhdGVzKFthZGRyZXNzXSkgPz8gW107XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHdyaXRlOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVDZXJ0aWZpY2F0ZTogYXN5bmMgKHBhcmFtczogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWNlcnRpZmljYXRlc1dyaXRlKSB0aHJvdyBuZXcgRXJyb3IoJ9i52YLYryDYp9mE2YPYqtin2KjYqSDYutmK2LEg2YXYqtmI2YHYsSB8IFdyaXRlIGNvbnRyYWN0IG5vdCBhdmFpbGFibGUnKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBjZXJ0aWZpY2F0ZXNXcml0ZS53cml0ZS5pc3N1ZUNlcnRpZmljYXRlKHBhcmFtcy5hcmdzKTtcbiAgICAgICAgICAgICAgICAgIGlmICghaGFzaCkgdGhyb3cgbmV3IEVycm9yKCfZgdi02YQg2YHZiiDYpdi12K/Yp9ixINin2YTYtNmH2KfYr9ipIHwgRmFpbGVkIHRvIGlzc3VlIGNlcnRpZmljYXRlJyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4geyB3YWl0OiBhc3luYyAoKSA9PiB7IGF3YWl0IHB1YmxpY0NsaWVudC53YWl0Rm9yVHJhbnNhY3Rpb25SZWNlaXB0KHsgaGFzaCB9KTsgfSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBhcyBDZXJ0aWZpY2F0ZXNDb250cmFjdCxcbiAgICAgICAgICAgIGlzQ29ubmVjdGVkOiB0cnVlLFxuICAgICAgICAgICAgaXNJbml0aWFsaXplZDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvbkVycm9yOiBudWxsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHNldFN0YXRlKHByZXYgPT4gKHtcbiAgICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgICAuLi5uZXdTdGF0ZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ29udHJhY3QgaW5pdGlhbGl6YXRpb24gY29tcGxldGUnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSW5pdGlhbGl6YXRpb24gZXJyb3I6Jywge1xuICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8ge1xuICAgICAgICAgICAgbmFtZTogZXJyb3IubmFtZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGFjazogZXJyb3Iuc3RhY2tcbiAgICAgICAgICB9IDogJ1Vua25vd24gZXJyb3InLFxuICAgICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICBoYXNBY2NvdW50OiAhIWFjY291bnQsXG4gICAgICAgICAgICBoYXNXYWxsZXRDbGllbnQ6ICEhd2FsbGV0Q2xpZW50LFxuICAgICAgICAgICAgaGFzUHVibGljQ2xpZW50OiAhIXB1YmxpY0NsaWVudCxcbiAgICAgICAgICAgIGNoYWluSWQ6IGNoYWluSWQsXG4gICAgICAgICAgICB0YXJnZXRDaGFpbklkOiBUQVJHRVRfQ0hBSU5fSURcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpc01vdW50ZWQpIHtcbiAgICAgICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgICAgZXhhbU1hbmFnZW1lbnRDb250cmFjdDogbnVsbCxcbiAgICAgICAgICAgIGNlcnRpZmljYXRlc0NvbnRyYWN0OiBudWxsLFxuICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGlzSW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaXNDb25uZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25FcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcidcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICB0b2FzdCh7XG4gICAgICAgICAgICB0aXRsZTogJ9iu2LfYoyDZgdmKINin2YTYqtmH2YrYptipIHwgSW5pdGlhbGl6YXRpb24gRXJyb3InLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgXG4gICAgICAgICAgICAgID8gYCR7ZXJyb3IubWVzc2FnZX0gfCDZitix2KzZiSDYp9mE2KrYo9mD2K8g2YXZhiDYp9iq2LXYp9mEINin2YTZhdit2YHYuNipINmI2KfZhNi02KjZg9ipINin2YTYtdit2YrYrdipYFxuICAgICAgICAgICAgICA6ICfYrdiv2Ksg2K7Yt9ijINi62YrYsSDZhdi52LHZiNmBIHwgQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCcsXG4gICAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgICBkdXJhdGlvbjogNTAwMCxcbiAgICAgICAgICAgIGlzQ2xvc2FibGU6IHRydWUsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaW5pdGlhbGl6ZUNvbnRyYWN0cygpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlzTW91bnRlZCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFthY2NvdW50LCB3YWxsZXRDbGllbnQsIHB1YmxpY0NsaWVudCwgY2hhaW5JZCwgdG9hc3RdKTtcblxuICAvLyBIYW5kbGUgbmV0d29yayBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5ldGhlcmV1bT8ub24pIHtcbiAgICAgIGNvbnN0IGhhbmRsZUNoYWluQ2hhbmdlZCA9ICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ05ldHdvcmsgY2hhbmdlZCwgcmVzZXR0aW5nIHN0YXRlLi4uJyk7XG4gICAgICAgIHNldFN0YXRlKHByZXYgPT4gKHtcbiAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgIGV4YW1NYW5hZ2VtZW50Q29udHJhY3Q6IG51bGwsXG4gICAgICAgICAgY2VydGlmaWNhdGVzQ29udHJhY3Q6IG51bGwsXG4gICAgICAgICAgZXhhbWluYXRpb25zQ29udHJhY3Q6IG51bGwsXG4gICAgICAgICAgaWRlbnRpdHlDb250cmFjdDogbnVsbCxcbiAgICAgICAgICBzZWN1cml0eVV0aWxzQ29udHJhY3Q6IG51bGwsXG4gICAgICAgICAgaXNJbml0aWFsaXplZDogZmFsc2UsXG4gICAgICAgICAgaXNDb25uZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgaW5pdGlhbGl6YXRpb25FcnJvcjogbnVsbFxuICAgICAgICB9KSk7XG4gICAgICB9O1xuXG4gICAgICB3aW5kb3cuZXRoZXJldW0ub24oJ2NoYWluQ2hhbmdlZCcsIGhhbmRsZUNoYWluQ2hhbmdlZCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAod2luZG93LmV0aGVyZXVtPy5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICAgIHdpbmRvdy5ldGhlcmV1bS5yZW1vdmVMaXN0ZW5lcignY2hhaW5DaGFuZ2VkJywgaGFuZGxlQ2hhaW5DaGFuZ2VkKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICByZXR1cm4ge1xuICAgIGV4YW1NYW5hZ2VtZW50Q29udHJhY3Q6IHN0YXRlLmV4YW1NYW5hZ2VtZW50Q29udHJhY3QsXG4gICAgY2VydGlmaWNhdGVzQ29udHJhY3Q6IHN0YXRlLmNlcnRpZmljYXRlc0NvbnRyYWN0LFxuICAgIGV4YW1pbmF0aW9uc0NvbnRyYWN0OiBzdGF0ZS5leGFtaW5hdGlvbnNDb250cmFjdCxcbiAgICBpZGVudGl0eUNvbnRyYWN0OiBzdGF0ZS5pZGVudGl0eUNvbnRyYWN0LFxuICAgIHNlY3VyaXR5VXRpbHNDb250cmFjdDogc3RhdGUuc2VjdXJpdHlVdGlsc0NvbnRyYWN0LFxuICAgIGFjY291bnQsXG4gICAgaXNDb25uZWN0ZWQ6IHN0YXRlLmlzQ29ubmVjdGVkLFxuICAgIGlzSW5pdGlhbGl6ZWQ6IHN0YXRlLmlzSW5pdGlhbGl6ZWQsXG4gICAgaXNMb2FkaW5nOiBzdGF0ZS5pc0xvYWRpbmcsXG4gICAgaXNDb3JyZWN0TmV0d29yazogY2hhaW5JZCA9PT0gVEFSR0VUX0NIQUlOX0lELFxuICAgIGluaXRpYWxpemF0aW9uRXJyb3I6IHN0YXRlLmluaXRpYWxpemF0aW9uRXJyb3JcbiAgfTtcbn07ICJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsInVzZUFjY291bnQiLCJ1c2VQdWJsaWNDbGllbnQiLCJ1c2VXYWxsZXRDbGllbnQiLCJ1c2VDaGFpbklkIiwidXNlQ29ubmVjdCIsImdldENvbnRyYWN0IiwiRXhhbU1hbmFnZW1lbnRBQkkiLCJDZXJ0aWZpY2F0ZXNBQkkiLCJ1c2VUb2FzdCIsIkVYQU1fTUFOQUdFTUVOVF9BRERSRVNTIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0VYQU1fTUFOQUdFTUVOVF9DT05UUkFDVF9BRERSRVNTIiwiQ0VSVElGSUNBVEVTX0FERFJFU1MiLCJORVhUX1BVQkxJQ19DRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUyIsIkVYQU1JTkFUSU9OU19BRERSRVNTIiwiTkVYVF9QVUJMSUNfRVhBTUlOQVRJT05TX0NPTlRSQUNUX0FERFJFU1MiLCJJREVOVElUWV9BRERSRVNTIiwiTkVYVF9QVUJMSUNfSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyIsIlNFQ1VSSVRZX1VUSUxTX0FERFJFU1MiLCJORVhUX1BVQkxJQ19TRUNVUklUWV9VVElMU19DT05UUkFDVF9BRERSRVNTIiwiVEFSR0VUX0NIQUlOX0lEIiwidXNlQ29udHJhY3QiLCJhZGRyZXNzIiwiYWNjb3VudCIsInB1YmxpY0NsaWVudCIsImRhdGEiLCJ3YWxsZXRDbGllbnQiLCJjaGFpbklkIiwiY29ubmVjdCIsInRvYXN0Iiwic3RhdGUiLCJzZXRTdGF0ZSIsImV4YW1NYW5hZ2VtZW50Q29udHJhY3QiLCJjZXJ0aWZpY2F0ZXNDb250cmFjdCIsImV4YW1pbmF0aW9uc0NvbnRyYWN0IiwiaWRlbnRpdHlDb250cmFjdCIsInNlY3VyaXR5VXRpbHNDb250cmFjdCIsImlzQ29ubmVjdGVkIiwiaXNJbml0aWFsaXplZCIsImlzTG9hZGluZyIsIm5ldHdvcmtTd2l0Y2hBdHRlbXB0ZWQiLCJpbml0aWFsaXphdGlvbkF0dGVtcHRlZCIsImluaXRpYWxpemF0aW9uRXJyb3IiLCJpc01vdW50ZWQiLCJzd2l0Y2hBdHRlbXB0cyIsIk1BWF9TV0lUQ0hfQVRURU1QVFMiLCJ2ZXJpZnlOZXR3b3JrIiwiZXhwZWN0ZWRDaGFpbklkIiwiY29uc29sZSIsImVycm9yIiwiY3VycmVudENoYWluSWQiLCJnZXRDaGFpbklkIiwibG9nIiwid2FpdEZvck5ldHdvcmtTd2l0Y2giLCJtYXhBdHRlbXB0cyIsImludGVydmFsIiwiYXR0ZW1wdHMiLCJpc0NvcnJlY3ROZXR3b3JrIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0Iiwic3dpdGNoTmV0d29yayIsIndpbmRvdyIsImV0aGVyZXVtIiwiRXJyb3IiLCJyZXF1ZXN0IiwibWV0aG9kIiwicGFyYW1zIiwidG9TdHJpbmciLCJzd2l0Y2hFcnJvciIsImNvZGUiLCJjaGFpbk5hbWUiLCJycGNVcmxzIiwibmF0aXZlQ3VycmVuY3kiLCJuYW1lIiwic3ltYm9sIiwiZGVjaW1hbHMiLCJpbml0aWFsaXplQ29udHJhY3RzIiwicHJldiIsImhhc0FjY291bnQiLCJoYXNXYWxsZXRDbGllbnQiLCJmaW5hbENoZWNrIiwiZXhhbUNvZGUiLCJjZXJ0Q29kZSIsImFsbCIsImdldEJ5dGVjb2RlIiwiZXhhbU1hbmFnZW1lbnRSZWFkIiwiYWJpIiwiY2xpZW50IiwiY2VydGlmaWNhdGVzUmVhZCIsImV4YW1NYW5hZ2VtZW50V3JpdGUiLCJjZXJ0aWZpY2F0ZXNXcml0ZSIsImlzSW5zdGl0dXRpb25SZXN1bHQiLCJjZXJ0aWZpY2F0ZXNSZXN1bHQiLCJyZWFkIiwiaXNJbnN0aXR1dGlvbiIsImdldEluc3RpdHV0aW9uQ2VydGlmaWNhdGVzIiwibmV3U3RhdGUiLCJyZXN1bHQiLCJnZXRJbnN0aXR1dGlvbiIsImdldEluc3RpdHV0aW9uRXhhbXMiLCJnZXRFeGFtUmVzdWx0cyIsImV4YW1JZCIsIndyaXRlIiwidXBkYXRlSW5zdGl0dXRpb25Qcm9maWxlIiwiaGFzaCIsImFyZ3MiLCJ3YWl0Iiwid2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdCIsInN1Ym1pdEV4YW1SZXN1bHRzIiwicmVnaXN0ZXJTdHVkZW50cyIsInVwZGF0ZUV4YW1TdGF0dXMiLCJjcmVhdGVFeGFtIiwiaXNzdWVDZXJ0aWZpY2F0ZSIsIm1lc3NhZ2UiLCJzdGFjayIsImhhc1B1YmxpY0NsaWVudCIsInRhcmdldENoYWluSWQiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwic3RhdHVzIiwiZHVyYXRpb24iLCJpc0Nsb3NhYmxlIiwib24iLCJoYW5kbGVDaGFpbkNoYW5nZWQiLCJyZW1vdmVMaXN0ZW5lciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./hooks/useContract.ts\n"));

/***/ })

});