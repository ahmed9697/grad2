"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./utils/ethersConfig.ts":
/*!*******************************!*\
  !*** ./utils/ethersConfig.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXPECTED_NETWORK: function() { return /* binding */ EXPECTED_NETWORK; },\n/* harmony export */   formatEther: function() { return /* binding */ formatEther; },\n/* harmony export */   getContract: function() { return /* binding */ getContract; },\n/* harmony export */   getProvider: function() { return /* binding */ getProvider; },\n/* harmony export */   getSigner: function() { return /* binding */ getSigner; },\n/* harmony export */   handleContractError: function() { return /* binding */ handleContractError; },\n/* harmony export */   switchToCorrectNetwork: function() { return /* binding */ switchToCorrectNetwork; },\n/* harmony export */   validateAddress: function() { return /* binding */ validateAddress; },\n/* harmony export */   validateNetwork: function() { return /* binding */ validateNetwork; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ \"./node_modules/ethers/lib.esm/index.js\");\nvar _window_ethereum;\n\n// Network configuration\nconst EXPECTED_NETWORK = {\n    chainId: \"1337\",\n    chainIdHex: \"0x539\",\n    name: \"Localhost\",\n    rpcUrl: \"http://127.0.0.1:7545\",\n    nativeCurrency: {\n        name: \"ETH\",\n        symbol: \"ETH\",\n        decimals: 18\n    }\n};\n// Function to switch to the correct network\nconst switchToCorrectNetwork = async (ethereum)=>{\n    try {\n        console.log(\"Attempting to switch network...\");\n        // First check current network\n        const currentChainId = await ethereum.request({\n            method: \"eth_chainId\"\n        });\n        console.log(\"Current chainId:\", currentChainId);\n        if (currentChainId === EXPECTED_NETWORK.chainIdHex) {\n            console.log(\"Already on correct network\");\n            return;\n        }\n        console.log(\"Switching to network:\", EXPECTED_NETWORK.chainIdHex);\n        // Try to switch to the network\n        await ethereum.request({\n            method: \"wallet_switchEthereumChain\",\n            params: [\n                {\n                    chainId: EXPECTED_NETWORK.chainIdHex\n                }\n            ]\n        });\n        // Wait a bit for the network switch to complete\n        await new Promise((resolve)=>setTimeout(resolve, 1000));\n        // Verify the switch was successful\n        const newChainId = await ethereum.request({\n            method: \"eth_chainId\"\n        });\n        if (newChainId !== EXPECTED_NETWORK.chainIdHex) {\n            throw new Error(\"Network switch failed\");\n        }\n        console.log(\"Successfully switched to correct network\");\n    } catch (switchError) {\n        console.error(\"Error in switchToCorrectNetwork:\", switchError);\n        // This error code indicates that the chain has not been added to MetaMask\n        if (switchError.code === 4902) {\n            try {\n                console.log(\"Network not found, attempting to add...\");\n                await ethereum.request({\n                    method: \"wallet_addEthereumChain\",\n                    params: [\n                        {\n                            chainId: EXPECTED_NETWORK.chainIdHex,\n                            chainName: EXPECTED_NETWORK.name,\n                            rpcUrls: [\n                                EXPECTED_NETWORK.rpcUrl\n                            ],\n                            nativeCurrency: EXPECTED_NETWORK.nativeCurrency\n                        }\n                    ]\n                });\n                // Wait a bit for the network to be added\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                // Verify the network was added and switched to\n                const finalChainId = await ethereum.request({\n                    method: \"eth_chainId\"\n                });\n                if (finalChainId !== EXPECTED_NETWORK.chainIdHex) {\n                    throw new Error(\"Network add failed\");\n                }\n                console.log(\"Successfully added and switched to network\");\n            } catch (addError) {\n                console.error(\"Error adding network:\", addError);\n                throw new Error(\"يرجى إضافة الشبكة المحلية يدوياً | Please add the local network manually\");\n            }\n        } else {\n            console.error(\"Error switching network:\", switchError);\n            throw new Error(\"يرجى تغيير الشبكة إلى الشبكة المحلية | Please switch to local network\");\n        }\n    }\n};\n// Provider and signer functions\nconst getProvider = async ()=>{\n    if (!window.ethereum) {\n        throw new Error(\"MetaMask غير مثبت - MetaMask is not installed\");\n    }\n    try {\n        // First check if we're on the correct network before doing anything else\n        const currentChainId = await window.ethereum.request({\n            method: \"eth_chainId\"\n        });\n        console.log(\"Initial chain ID check:\", currentChainId);\n        if (currentChainId !== EXPECTED_NETWORK.chainIdHex) {\n            console.log(\"Wrong network detected, attempting to switch...\");\n            await switchToCorrectNetwork(window.ethereum);\n            // Verify the switch was successful\n            const newChainId = await window.ethereum.request({\n                method: \"eth_chainId\"\n            });\n            if (newChainId !== EXPECTED_NETWORK.chainIdHex) {\n                throw new Error(\"Failed to switch to correct network\");\n            }\n        }\n        // Only request accounts after we're on the correct network\n        await window.ethereum.request({\n            method: \"eth_requestAccounts\"\n        });\n        // Create provider using BrowserProvider\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_0__.BrowserProvider(window.ethereum);\n        return provider;\n    } catch (error) {\n        console.error(\"Error getting provider:\", error);\n        throw error;\n    }\n};\nconst getSigner = async ()=>{\n    const provider = await getProvider();\n    return provider.getSigner();\n};\nconst validateNetwork = async (provider)=>{\n    try {\n        console.log(\"Validating network...\");\n        const network = await provider.getNetwork();\n        const chainId = network.chainId.toString();\n        console.log(\"Current chainId:\", chainId, \"Expected:\", EXPECTED_NETWORK.chainId);\n        if (chainId !== EXPECTED_NETWORK.chainId) {\n            console.log(\"Wrong network detected in validateNetwork\");\n            if (!window.ethereum) {\n                throw new Error(\"يرجى الاتصال بشبكة \".concat(EXPECTED_NETWORK.name, \" (Chain ID: \").concat(EXPECTED_NETWORK.chainId, \") | Please connect to \").concat(EXPECTED_NETWORK.name, \" network\"));\n            }\n            // Get the current chain ID directly from ethereum provider\n            const currentChainId = await window.ethereum.request({\n                method: \"eth_chainId\"\n            });\n            console.log(\"Current chain ID from ethereum:\", currentChainId);\n            if (currentChainId !== EXPECTED_NETWORK.chainIdHex) {\n                await switchToCorrectNetwork(window.ethereum);\n                // Wait for the network switch to complete\n                await new Promise((resolve)=>setTimeout(resolve, 1500));\n                // Verify one final time\n                const finalChainId = await window.ethereum.request({\n                    method: \"eth_chainId\"\n                });\n                if (finalChainId !== EXPECTED_NETWORK.chainIdHex) {\n                    throw new Error(\"Network switch verification failed\");\n                }\n            }\n        }\n        console.log(\"Network validation passed\");\n    } catch (error) {\n        console.error(\"Network validation failed:\", error);\n        throw error;\n    }\n};\n// Helper functions for working with contracts\nconst getContract = (address, abi, signer)=>{\n    return new ethers__WEBPACK_IMPORTED_MODULE_0__.Contract(address, abi, signer);\n};\nconst validateAddress = (address)=>{\n    if (!address) {\n        throw new Error(\"Address is required\");\n    }\n    try {\n        return (0,ethers__WEBPACK_IMPORTED_MODULE_0__.getAddress)(address);\n    } catch (error) {\n        throw new Error(\"Invalid Ethereum address\");\n    }\n};\nconst formatEther = (value)=>{\n    return (0,ethers__WEBPACK_IMPORTED_MODULE_0__.formatUnits)(value, 18);\n};\n// Utility function to handle common contract errors\nconst handleContractError = (error)=>{\n    var _error_message, _error_message1, _error_message2;\n    console.error(\"Contract error:\", error);\n    if (error.reason) {\n        throw new Error(\"Smart contract error: \".concat(error.reason));\n    } else if ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"user rejected\")) {\n        throw new Error(\"Transaction rejected by user\");\n    } else if ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"insufficient funds\")) {\n        throw new Error(\"Insufficient funds to complete the transaction\");\n    } else if ((_error_message2 = error.message) === null || _error_message2 === void 0 ? void 0 : _error_message2.includes(\"network\")) {\n        throw new Error(\"Please make sure you are connected to the correct network\");\n    } else {\n        throw new Error(\"Transaction failed. Please check your connection and try again.\");\n    }\n};\n// Event listener for network changes\nif ( true && ((_window_ethereum = window.ethereum) === null || _window_ethereum === void 0 ? void 0 : _window_ethereum.on)) {\n    window.ethereum.on(\"chainChanged\", (chainId)=>{\n        console.log(\"Network changed to:\", chainId);\n        if (chainId !== EXPECTED_NETWORK.chainIdHex) {\n            console.log(\"Wrong network after change, reloading...\");\n            window.location.reload();\n        }\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFBc0IsQ0FBQ3BCO1FBS3ZCQSxnQkFFQUEsaUJBRUFBO0lBUlhaLFFBQVFZLEtBQUssQ0FBQyxtQkFBbUJBO0lBRWpDLElBQUlBLE1BQU1xQixNQUFNLEVBQUU7UUFDaEIsTUFBTSxJQUFJdkIsTUFBTSx5QkFBc0MsT0FBYkUsTUFBTXFCLE1BQU07SUFDdkQsT0FBTyxLQUFJckIsaUJBQUFBLE1BQU1zQixPQUFPLGNBQWJ0QixxQ0FBQUEsZUFBZXVCLFFBQVEsQ0FBQyxrQkFBa0I7UUFDbkQsTUFBTSxJQUFJekIsTUFBTTtJQUNsQixPQUFPLEtBQUlFLGtCQUFBQSxNQUFNc0IsT0FBTyxjQUFidEIsc0NBQUFBLGdCQUFldUIsUUFBUSxDQUFDLHVCQUF1QjtRQUN4RCxNQUFNLElBQUl6QixNQUFNO0lBQ2xCLE9BQU8sS0FBSUUsa0JBQUFBLE1BQU1zQixPQUFPLGNBQWJ0QixzQ0FBQUEsZ0JBQWV1QixRQUFRLENBQUMsWUFBWTtRQUM3QyxNQUFNLElBQUl6QixNQUFNO0lBQ2xCLE9BQU87UUFDTCxNQUFNLElBQUlBLE1BQU07SUFDbEI7QUFDRixFQUFFO0FBRUYscUNBQXFDO0FBQ3JDLElBQUksS0FBa0IsTUFBZXpCLG1CQUFBQSxPQUFPYyxRQUFRLGNBQWZkLHVDQUFBQSxpQkFBaUJtRCxFQUFFLEdBQUU7SUFDeERuRCxPQUFPYyxRQUFRLENBQUNxQyxFQUFFLENBQUMsZ0JBQWdCLENBQUM3QztRQUNsQ1MsUUFBUUMsR0FBRyxDQUFDLHVCQUF1QlY7UUFDbkMsSUFBSUEsWUFBWUQsaUJBQWlCRSxVQUFVLEVBQUU7WUFDM0NRLFFBQVFDLEdBQUcsQ0FBQztZQUNaaEIsT0FBT29ELFFBQVEsQ0FBQ0MsTUFBTTtRQUN4QjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvZXRoZXJzQ29uZmlnLnRzPzU2YjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgXG4gIENvbnRyYWN0LCBcbiAgSnNvblJwY1Byb3ZpZGVyLCBcbiAgQnJvd3NlclByb3ZpZGVyLFxuICBmb3JtYXRVbml0cywgXG4gIGdldEFkZHJlc3MsXG4gIHR5cGUgSnNvblJwY1NpZ25lcixcbiAgdHlwZSBQcm92aWRlclxufSBmcm9tICdldGhlcnMnO1xuXG4vLyBUeXBlc1xuZXhwb3J0IGludGVyZmFjZSBSZXF1ZXN0QXJndW1lbnRzIHtcbiAgbWV0aG9kOiBzdHJpbmc7XG4gIHBhcmFtcz86IHVua25vd25bXSB8IG9iamVjdDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFdGhlcmV1bVByb3ZpZGVyIHtcbiAgcmVxdWVzdChhcmdzOiBSZXF1ZXN0QXJndW1lbnRzKTogUHJvbWlzZTx1bmtub3duPjtcbiAgb24/KGV2ZW50TmFtZTogc3RyaW5nLCBjYWxsYmFjazogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkKTogdm9pZDtcbiAgcmVtb3ZlTGlzdGVuZXI/KGV2ZW50TmFtZTogc3RyaW5nLCBjYWxsYmFjazogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkKTogdm9pZDtcbiAgc2VsZWN0ZWRBZGRyZXNzPzogc3RyaW5nO1xuICBpc01ldGFNYXNrPzogYm9vbGVhbjtcbiAgY2hhaW5JZD86IHN0cmluZztcbiAgbmV0d29ya1ZlcnNpb24/OiBzdHJpbmc7XG59XG5cbi8vIEFkZCB0eXBlIGRlY2xhcmF0aW9uIGZvciB0aGUgZ2xvYmFsIHdpbmRvdyBvYmplY3RcbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgZXRoZXJldW0/OiBFdGhlcmV1bVByb3ZpZGVyO1xuICB9XG59XG5cbi8vIE5ldHdvcmsgY29uZmlndXJhdGlvblxuZXhwb3J0IGNvbnN0IEVYUEVDVEVEX05FVFdPUksgPSB7XG4gIGNoYWluSWQ6ICcxMzM3JyxcbiAgY2hhaW5JZEhleDogJzB4NTM5JywgLy8gSGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgMTMzN1xuICBuYW1lOiAnTG9jYWxob3N0JyxcbiAgcnBjVXJsOiAnaHR0cDovLzEyNy4wLjAuMTo3NTQ1JyxcbiAgbmF0aXZlQ3VycmVuY3k6IHtcbiAgICBuYW1lOiAnRVRIJyxcbiAgICBzeW1ib2w6ICdFVEgnLFxuICAgIGRlY2ltYWxzOiAxOFxuICB9XG59O1xuXG4vLyBGdW5jdGlvbiB0byBzd2l0Y2ggdG8gdGhlIGNvcnJlY3QgbmV0d29ya1xuZXhwb3J0IGNvbnN0IHN3aXRjaFRvQ29ycmVjdE5ldHdvcmsgPSBhc3luYyAoZXRoZXJldW06IEV0aGVyZXVtUHJvdmlkZXIpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnQXR0ZW1wdGluZyB0byBzd2l0Y2ggbmV0d29yay4uLicpO1xuICAgIC8vIEZpcnN0IGNoZWNrIGN1cnJlbnQgbmV0d29ya1xuICAgIGNvbnN0IGN1cnJlbnRDaGFpbklkID0gYXdhaXQgZXRoZXJldW0ucmVxdWVzdCh7IG1ldGhvZDogJ2V0aF9jaGFpbklkJyB9KTtcbiAgICBjb25zb2xlLmxvZygnQ3VycmVudCBjaGFpbklkOicsIGN1cnJlbnRDaGFpbklkKTtcbiAgICBcbiAgICBpZiAoY3VycmVudENoYWluSWQgPT09IEVYUEVDVEVEX05FVFdPUksuY2hhaW5JZEhleCkge1xuICAgICAgY29uc29sZS5sb2coJ0FscmVhZHkgb24gY29ycmVjdCBuZXR3b3JrJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1N3aXRjaGluZyB0byBuZXR3b3JrOicsIEVYUEVDVEVEX05FVFdPUksuY2hhaW5JZEhleCk7XG4gICAgXG4gICAgLy8gVHJ5IHRvIHN3aXRjaCB0byB0aGUgbmV0d29ya1xuICAgIGF3YWl0IGV0aGVyZXVtLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiAnd2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW4nLFxuICAgICAgcGFyYW1zOiBbeyBjaGFpbklkOiBFWFBFQ1RFRF9ORVRXT1JLLmNoYWluSWRIZXggfV1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBXYWl0IGEgYml0IGZvciB0aGUgbmV0d29yayBzd2l0Y2ggdG8gY29tcGxldGVcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpO1xuICAgIFxuICAgIC8vIFZlcmlmeSB0aGUgc3dpdGNoIHdhcyBzdWNjZXNzZnVsXG4gICAgY29uc3QgbmV3Q2hhaW5JZCA9IGF3YWl0IGV0aGVyZXVtLnJlcXVlc3QoeyBtZXRob2Q6ICdldGhfY2hhaW5JZCcgfSk7XG4gICAgaWYgKG5ld0NoYWluSWQgIT09IEVYUEVDVEVEX05FVFdPUksuY2hhaW5JZEhleCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXR3b3JrIHN3aXRjaCBmYWlsZWQnKTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ1N1Y2Nlc3NmdWxseSBzd2l0Y2hlZCB0byBjb3JyZWN0IG5ldHdvcmsnKTtcbiAgfSBjYXRjaCAoc3dpdGNoRXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHN3aXRjaFRvQ29ycmVjdE5ldHdvcms6Jywgc3dpdGNoRXJyb3IpO1xuICAgIFxuICAgIC8vIFRoaXMgZXJyb3IgY29kZSBpbmRpY2F0ZXMgdGhhdCB0aGUgY2hhaW4gaGFzIG5vdCBiZWVuIGFkZGVkIHRvIE1ldGFNYXNrXG4gICAgaWYgKHN3aXRjaEVycm9yLmNvZGUgPT09IDQ5MDIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdOZXR3b3JrIG5vdCBmb3VuZCwgYXR0ZW1wdGluZyB0byBhZGQuLi4nKTtcbiAgICAgICAgYXdhaXQgZXRoZXJldW0ucmVxdWVzdCh7XG4gICAgICAgICAgbWV0aG9kOiAnd2FsbGV0X2FkZEV0aGVyZXVtQ2hhaW4nLFxuICAgICAgICAgIHBhcmFtczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjaGFpbklkOiBFWFBFQ1RFRF9ORVRXT1JLLmNoYWluSWRIZXgsXG4gICAgICAgICAgICAgIGNoYWluTmFtZTogRVhQRUNURURfTkVUV09SSy5uYW1lLFxuICAgICAgICAgICAgICBycGNVcmxzOiBbRVhQRUNURURfTkVUV09SSy5ycGNVcmxdLFxuICAgICAgICAgICAgICBuYXRpdmVDdXJyZW5jeTogRVhQRUNURURfTkVUV09SSy5uYXRpdmVDdXJyZW5jeVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBXYWl0IGEgYml0IGZvciB0aGUgbmV0d29yayB0byBiZSBhZGRlZFxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpO1xuICAgICAgICBcbiAgICAgICAgLy8gVmVyaWZ5IHRoZSBuZXR3b3JrIHdhcyBhZGRlZCBhbmQgc3dpdGNoZWQgdG9cbiAgICAgICAgY29uc3QgZmluYWxDaGFpbklkID0gYXdhaXQgZXRoZXJldW0ucmVxdWVzdCh7IG1ldGhvZDogJ2V0aF9jaGFpbklkJyB9KTtcbiAgICAgICAgaWYgKGZpbmFsQ2hhaW5JZCAhPT0gRVhQRUNURURfTkVUV09SSy5jaGFpbklkSGV4KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXR3b3JrIGFkZCBmYWlsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coJ1N1Y2Nlc3NmdWxseSBhZGRlZCBhbmQgc3dpdGNoZWQgdG8gbmV0d29yaycpO1xuICAgICAgfSBjYXRjaCAoYWRkRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIG5ldHdvcms6JywgYWRkRXJyb3IpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ9mK2LHYrNmJINil2LbYp9mB2Kkg2KfZhNi02KjZg9ipINin2YTZhdit2YTZitipINmK2K/ZiNmK2KfZiyB8IFBsZWFzZSBhZGQgdGhlIGxvY2FsIG5ldHdvcmsgbWFudWFsbHknKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc3dpdGNoaW5nIG5ldHdvcms6Jywgc3dpdGNoRXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCfZitix2KzZiSDYqti62YrZitixINin2YTYtNio2YPYqSDYpdmE2Ykg2KfZhNi02KjZg9ipINin2YTZhdit2YTZitipIHwgUGxlYXNlIHN3aXRjaCB0byBsb2NhbCBuZXR3b3JrJyk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBQcm92aWRlciBhbmQgc2lnbmVyIGZ1bmN0aW9uc1xuZXhwb3J0IGNvbnN0IGdldFByb3ZpZGVyID0gYXN5bmMgKCkgPT4ge1xuICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0YU1hc2sg2LrZitixINmF2KvYqNiqIC0gTWV0YU1hc2sgaXMgbm90IGluc3RhbGxlZCcpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBGaXJzdCBjaGVjayBpZiB3ZSdyZSBvbiB0aGUgY29ycmVjdCBuZXR3b3JrIGJlZm9yZSBkb2luZyBhbnl0aGluZyBlbHNlXG4gICAgY29uc3QgY3VycmVudENoYWluSWQgPSBhd2FpdCB3aW5kb3cuZXRoZXJldW0ucmVxdWVzdCh7IG1ldGhvZDogJ2V0aF9jaGFpbklkJyB9KTtcbiAgICBjb25zb2xlLmxvZygnSW5pdGlhbCBjaGFpbiBJRCBjaGVjazonLCBjdXJyZW50Q2hhaW5JZCk7XG4gICAgXG4gICAgaWYgKGN1cnJlbnRDaGFpbklkICE9PSBFWFBFQ1RFRF9ORVRXT1JLLmNoYWluSWRIZXgpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdXcm9uZyBuZXR3b3JrIGRldGVjdGVkLCBhdHRlbXB0aW5nIHRvIHN3aXRjaC4uLicpO1xuICAgICAgYXdhaXQgc3dpdGNoVG9Db3JyZWN0TmV0d29yayh3aW5kb3cuZXRoZXJldW0pO1xuICAgICAgXG4gICAgICAvLyBWZXJpZnkgdGhlIHN3aXRjaCB3YXMgc3VjY2Vzc2Z1bFxuICAgICAgY29uc3QgbmV3Q2hhaW5JZCA9IGF3YWl0IHdpbmRvdy5ldGhlcmV1bS5yZXF1ZXN0KHsgbWV0aG9kOiAnZXRoX2NoYWluSWQnIH0pO1xuICAgICAgaWYgKG5ld0NoYWluSWQgIT09IEVYUEVDVEVEX05FVFdPUksuY2hhaW5JZEhleCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzd2l0Y2ggdG8gY29ycmVjdCBuZXR3b3JrJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT25seSByZXF1ZXN0IGFjY291bnRzIGFmdGVyIHdlJ3JlIG9uIHRoZSBjb3JyZWN0IG5ldHdvcmtcbiAgICBhd2FpdCB3aW5kb3cuZXRoZXJldW0ucmVxdWVzdCh7IG1ldGhvZDogXCJldGhfcmVxdWVzdEFjY291bnRzXCIgfSk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIHByb3ZpZGVyIHVzaW5nIEJyb3dzZXJQcm92aWRlclxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IEJyb3dzZXJQcm92aWRlcih3aW5kb3cuZXRoZXJldW0pO1xuICAgIFxuICAgIHJldHVybiBwcm92aWRlcjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHByb3ZpZGVyOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldFNpZ25lciA9IGFzeW5jICgpOiBQcm9taXNlPEpzb25ScGNTaWduZXI+ID0+IHtcbiAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBnZXRQcm92aWRlcigpO1xuICByZXR1cm4gcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XG59O1xuXG5leHBvcnQgY29uc3QgdmFsaWRhdGVOZXR3b3JrID0gYXN5bmMgKHByb3ZpZGVyOiBQcm92aWRlcikgPT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdWYWxpZGF0aW5nIG5ldHdvcmsuLi4nKTtcbiAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgcHJvdmlkZXIuZ2V0TmV0d29yaygpO1xuICAgIGNvbnN0IGNoYWluSWQgPSBuZXR3b3JrLmNoYWluSWQudG9TdHJpbmcoKTtcbiAgICBjb25zb2xlLmxvZygnQ3VycmVudCBjaGFpbklkOicsIGNoYWluSWQsICdFeHBlY3RlZDonLCBFWFBFQ1RFRF9ORVRXT1JLLmNoYWluSWQpO1xuICAgIFxuICAgIGlmIChjaGFpbklkICE9PSBFWFBFQ1RFRF9ORVRXT1JLLmNoYWluSWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdXcm9uZyBuZXR3b3JrIGRldGVjdGVkIGluIHZhbGlkYXRlTmV0d29yaycpO1xuICAgICAgaWYgKCF3aW5kb3cuZXRoZXJldW0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGDZitix2KzZiSDYp9mE2KfYqti12KfZhCDYqNi02KjZg9ipICR7RVhQRUNURURfTkVUV09SSy5uYW1lfSAoQ2hhaW4gSUQ6ICR7RVhQRUNURURfTkVUV09SSy5jaGFpbklkfSkgfCBQbGVhc2UgY29ubmVjdCB0byAke0VYUEVDVEVEX05FVFdPUksubmFtZX0gbmV0d29ya2ApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgY2hhaW4gSUQgZGlyZWN0bHkgZnJvbSBldGhlcmV1bSBwcm92aWRlclxuICAgICAgY29uc3QgY3VycmVudENoYWluSWQgPSBhd2FpdCB3aW5kb3cuZXRoZXJldW0ucmVxdWVzdCh7IG1ldGhvZDogJ2V0aF9jaGFpbklkJyB9KTtcbiAgICAgIGNvbnNvbGUubG9nKCdDdXJyZW50IGNoYWluIElEIGZyb20gZXRoZXJldW06JywgY3VycmVudENoYWluSWQpO1xuICAgICAgXG4gICAgICBpZiAoY3VycmVudENoYWluSWQgIT09IEVYUEVDVEVEX05FVFdPUksuY2hhaW5JZEhleCkge1xuICAgICAgICBhd2FpdCBzd2l0Y2hUb0NvcnJlY3ROZXR3b3JrKHdpbmRvdy5ldGhlcmV1bSk7XG4gICAgICAgIFxuICAgICAgICAvLyBXYWl0IGZvciB0aGUgbmV0d29yayBzd2l0Y2ggdG8gY29tcGxldGVcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDE1MDApKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFZlcmlmeSBvbmUgZmluYWwgdGltZVxuICAgICAgICBjb25zdCBmaW5hbENoYWluSWQgPSBhd2FpdCB3aW5kb3cuZXRoZXJldW0ucmVxdWVzdCh7IG1ldGhvZDogJ2V0aF9jaGFpbklkJyB9KTtcbiAgICAgICAgaWYgKGZpbmFsQ2hhaW5JZCAhPT0gRVhQRUNURURfTkVUV09SSy5jaGFpbklkSGV4KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXR3b3JrIHN3aXRjaCB2ZXJpZmljYXRpb24gZmFpbGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ05ldHdvcmsgdmFsaWRhdGlvbiBwYXNzZWQnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdOZXR3b3JrIHZhbGlkYXRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3Igd29ya2luZyB3aXRoIGNvbnRyYWN0c1xuZXhwb3J0IGNvbnN0IGdldENvbnRyYWN0ID0gPFQgZXh0ZW5kcyBDb250cmFjdD4oXG4gIGFkZHJlc3M6IHN0cmluZyxcbiAgYWJpOiBhbnksXG4gIHNpZ25lcjogSnNvblJwY1NpZ25lclxuKTogVCA9PiB7XG4gIHJldHVybiBuZXcgQ29udHJhY3QoYWRkcmVzcywgYWJpLCBzaWduZXIpIGFzIFQ7XG59O1xuXG5leHBvcnQgY29uc3QgdmFsaWRhdGVBZGRyZXNzID0gKGFkZHJlc3M6IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGwpOiBzdHJpbmcgPT4ge1xuICBpZiAoIWFkZHJlc3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkZHJlc3MgaXMgcmVxdWlyZWQnKTtcbiAgfVxuICBcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgRXRoZXJldW0gYWRkcmVzcycpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZm9ybWF0RXRoZXIgPSAodmFsdWU6IGJpZ2ludCk6IHN0cmluZyA9PiB7XG4gIHJldHVybiBmb3JtYXRVbml0cyh2YWx1ZSwgMTgpO1xufTtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbiB0byBoYW5kbGUgY29tbW9uIGNvbnRyYWN0IGVycm9yc1xuZXhwb3J0IGNvbnN0IGhhbmRsZUNvbnRyYWN0RXJyb3IgPSAoZXJyb3I6IGFueSk6IG5ldmVyID0+IHtcbiAgY29uc29sZS5lcnJvcignQ29udHJhY3QgZXJyb3I6JywgZXJyb3IpO1xuICBcbiAgaWYgKGVycm9yLnJlYXNvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgU21hcnQgY29udHJhY3QgZXJyb3I6ICR7ZXJyb3IucmVhc29ufWApO1xuICB9IGVsc2UgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCd1c2VyIHJlamVjdGVkJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIHJlamVjdGVkIGJ5IHVzZXInKTtcbiAgfSBlbHNlIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnaW5zdWZmaWNpZW50IGZ1bmRzJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3VmZmljaWVudCBmdW5kcyB0byBjb21wbGV0ZSB0aGUgdHJhbnNhY3Rpb24nKTtcbiAgfSBlbHNlIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnbmV0d29yaycpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgbWFrZSBzdXJlIHlvdSBhcmUgY29ubmVjdGVkIHRvIHRoZSBjb3JyZWN0IG5ldHdvcmsnKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIGZhaWxlZC4gUGxlYXNlIGNoZWNrIHlvdXIgY29ubmVjdGlvbiBhbmQgdHJ5IGFnYWluLicpO1xuICB9XG59O1xuXG4vLyBFdmVudCBsaXN0ZW5lciBmb3IgbmV0d29yayBjaGFuZ2VzXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmV0aGVyZXVtPy5vbikge1xuICB3aW5kb3cuZXRoZXJldW0ub24oJ2NoYWluQ2hhbmdlZCcsIChjaGFpbklkOiBzdHJpbmcpID0+IHtcbiAgICBjb25zb2xlLmxvZygnTmV0d29yayBjaGFuZ2VkIHRvOicsIGNoYWluSWQpO1xuICAgIGlmIChjaGFpbklkICE9PSBFWFBFQ1RFRF9ORVRXT1JLLmNoYWluSWRIZXgpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdXcm9uZyBuZXR3b3JrIGFmdGVyIGNoYW5nZSwgcmVsb2FkaW5nLi4uJyk7XG4gICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgfVxuICB9KTtcbn0gIl0sIm5hbWVzIjpbIndpbmRvdyIsIkNvbnRyYWN0IiwiQnJvd3NlclByb3ZpZGVyIiwiZm9ybWF0VW5pdHMiLCJnZXRBZGRyZXNzIiwiRVhQRUNURURfTkVUV09SSyIsImNoYWluSWQiLCJjaGFpbklkSGV4IiwibmFtZSIsInJwY1VybCIsIm5hdGl2ZUN1cnJlbmN5Iiwic3ltYm9sIiwiZGVjaW1hbHMiLCJzd2l0Y2hUb0NvcnJlY3ROZXR3b3JrIiwiZXRoZXJldW0iLCJjb25zb2xlIiwibG9nIiwiY3VycmVudENoYWluSWQiLCJyZXF1ZXN0IiwibWV0aG9kIiwicGFyYW1zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwibmV3Q2hhaW5JZCIsIkVycm9yIiwic3dpdGNoRXJyb3IiLCJlcnJvciIsImNvZGUiLCJjaGFpbk5hbWUiLCJycGNVcmxzIiwiZmluYWxDaGFpbklkIiwiYWRkRXJyb3IiLCJnZXRQcm92aWRlciIsInByb3ZpZGVyIiwiZ2V0U2lnbmVyIiwidmFsaWRhdGVOZXR3b3JrIiwibmV0d29yayIsImdldE5ldHdvcmsiLCJ0b1N0cmluZyIsImdldENvbnRyYWN0IiwiYWRkcmVzcyIsImFiaSIsInNpZ25lciIsInZhbGlkYXRlQWRkcmVzcyIsImZvcm1hdEV0aGVyIiwidmFsdWUiLCJoYW5kbGVDb250cmFjdEVycm9yIiwicmVhc29uIiwibWVzc2FnZSIsImluY2x1ZGVzIiwib24iLCJsb2NhdGlvbiIsInJlbG9hZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/ethersConfig.ts\n"));

/***/ })

});