"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./utils/ethersConfig.ts":
/*!*******************************!*\
  !*** ./utils/ethersConfig.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXPECTED_NETWORK: function() { return /* binding */ EXPECTED_NETWORK; },\n/* harmony export */   formatEther: function() { return /* binding */ formatEther; },\n/* harmony export */   getContract: function() { return /* binding */ getContract; },\n/* harmony export */   getProvider: function() { return /* binding */ getProvider; },\n/* harmony export */   getSigner: function() { return /* binding */ getSigner; },\n/* harmony export */   handleContractError: function() { return /* binding */ handleContractError; },\n/* harmony export */   switchToCorrectNetwork: function() { return /* binding */ switchToCorrectNetwork; },\n/* harmony export */   validateAddress: function() { return /* binding */ validateAddress; },\n/* harmony export */   validateNetwork: function() { return /* binding */ validateNetwork; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ \"./node_modules/ethers/lib.esm/index.js\");\n\n// Network configuration\nconst EXPECTED_NETWORK = {\n    chainId: \"1337\",\n    chainIdHex: \"0x539\",\n    name: \"Localhost\",\n    rpcUrl: \"http://127.0.0.1:7545\",\n    nativeCurrency: {\n        name: \"ETH\",\n        symbol: \"ETH\",\n        decimals: 18\n    }\n};\n// Function to switch to the correct network\nconst switchToCorrectNetwork = async (ethereum)=>{\n    try {\n        console.log(\"Attempting to switch network...\");\n        // First check current network\n        const currentChainId = await ethereum.request({\n            method: \"eth_chainId\"\n        });\n        console.log(\"Current chainId:\", currentChainId);\n        if (currentChainId === EXPECTED_NETWORK.chainIdHex) {\n            console.log(\"Already on correct network\");\n            return;\n        }\n        console.log(\"Switching to network:\", EXPECTED_NETWORK.chainIdHex);\n        // Try to switch to the network\n        await ethereum.request({\n            method: \"wallet_switchEthereumChain\",\n            params: [\n                {\n                    chainId: EXPECTED_NETWORK.chainIdHex\n                }\n            ]\n        });\n        // Wait a bit for the network switch to complete\n        await new Promise((resolve)=>setTimeout(resolve, 1000));\n        // Verify the switch was successful\n        const newChainId = await ethereum.request({\n            method: \"eth_chainId\"\n        });\n        if (newChainId !== EXPECTED_NETWORK.chainIdHex) {\n            throw new Error(\"Network switch failed\");\n        }\n        console.log(\"Successfully switched to correct network\");\n    } catch (switchError) {\n        console.error(\"Error in switchToCorrectNetwork:\", switchError);\n        // This error code indicates that the chain has not been added to MetaMask\n        if (switchError.code === 4902) {\n            try {\n                console.log(\"Network not found, attempting to add...\");\n                await ethereum.request({\n                    method: \"wallet_addEthereumChain\",\n                    params: [\n                        {\n                            chainId: EXPECTED_NETWORK.chainIdHex,\n                            chainName: EXPECTED_NETWORK.name,\n                            rpcUrls: [\n                                EXPECTED_NETWORK.rpcUrl\n                            ],\n                            nativeCurrency: EXPECTED_NETWORK.nativeCurrency\n                        }\n                    ]\n                });\n                // Wait a bit for the network to be added\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                // Verify the network was added and switched to\n                const finalChainId = await ethereum.request({\n                    method: \"eth_chainId\"\n                });\n                if (finalChainId !== EXPECTED_NETWORK.chainIdHex) {\n                    throw new Error(\"Network add failed\");\n                }\n                console.log(\"Successfully added and switched to network\");\n            } catch (addError) {\n                console.error(\"Error adding network:\", addError);\n                throw new Error(\"يرجى إضافة الشبكة المحلية يدوياً | Please add the local network manually\");\n            }\n        } else {\n            console.error(\"Error switching network:\", switchError);\n            throw new Error(\"يرجى تغيير الشبكة إلى الشبكة المحلية | Please switch to local network\");\n        }\n    }\n};\n// Provider and signer functions\nconst getProvider = async ()=>{\n    if (!window.ethereum) {\n        throw new Error(\"MetaMask غير مثبت - MetaMask is not installed\");\n    }\n    try {\n        // Request account access\n        await window.ethereum.request({\n            method: \"eth_requestAccounts\"\n        });\n        // Create provider using BrowserProvider\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_0__.BrowserProvider(window.ethereum);\n        // Validate and switch network if needed\n        await validateNetwork(provider);\n        return provider;\n    } catch (error) {\n        console.error(\"Error getting provider:\", error);\n        throw error;\n    }\n};\nconst getSigner = async ()=>{\n    const provider = await getProvider();\n    return provider.getSigner();\n};\nconst validateNetwork = async (provider)=>{\n    try {\n        console.log(\"Validating network...\");\n        const network = await provider.getNetwork();\n        const chainId = network.chainId.toString();\n        console.log(\"Current chainId:\", chainId, \"Expected:\", EXPECTED_NETWORK.chainId);\n        if (chainId !== EXPECTED_NETWORK.chainId) {\n            console.log(\"Wrong network detected\");\n            if (window.ethereum) {\n                await switchToCorrectNetwork(window.ethereum);\n            } else {\n                throw new Error(\"يرجى الاتصال بشبكة \".concat(EXPECTED_NETWORK.name, \" (Chain ID: \").concat(EXPECTED_NETWORK.chainId, \") | Please connect to \").concat(EXPECTED_NETWORK.name, \" network\"));\n            }\n        } else {\n            console.log(\"Network validation passed\");\n        }\n    } catch (error) {\n        console.error(\"Network validation failed:\", error);\n        throw error;\n    }\n};\n// Helper functions for working with contracts\nconst getContract = (address, abi, signer)=>{\n    return new ethers__WEBPACK_IMPORTED_MODULE_0__.Contract(address, abi, signer);\n};\nconst validateAddress = (address)=>{\n    if (!address) {\n        throw new Error(\"Address is required\");\n    }\n    try {\n        return (0,ethers__WEBPACK_IMPORTED_MODULE_0__.getAddress)(address);\n    } catch (error) {\n        throw new Error(\"Invalid Ethereum address\");\n    }\n};\nconst formatEther = (value)=>{\n    return (0,ethers__WEBPACK_IMPORTED_MODULE_0__.formatUnits)(value, 18);\n};\n// Utility function to handle common contract errors\nconst handleContractError = (error)=>{\n    var _error_message, _error_message1, _error_message2;\n    console.error(\"Contract error:\", error);\n    if (error.reason) {\n        throw new Error(\"Smart contract error: \".concat(error.reason));\n    } else if ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"user rejected\")) {\n        throw new Error(\"Transaction rejected by user\");\n    } else if ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"insufficient funds\")) {\n        throw new Error(\"Insufficient funds to complete the transaction\");\n    } else if ((_error_message2 = error.message) === null || _error_message2 === void 0 ? void 0 : _error_message2.includes(\"network\")) {\n        throw new Error(\"Please make sure you are connected to the correct network\");\n    } else {\n        throw new Error(\"Transaction failed. Please check your connection and try again.\");\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVM7UUFDWixNQUFNLElBQUlqQixNQUFNO0lBQ2xCO0lBRUEsSUFBSTtRQUNGLE9BQU9yQixrREFBVUEsQ0FBQ3NDO0lBQ3BCLEVBQUUsT0FBT2YsT0FBTztRQUNkLE1BQU0sSUFBSUYsTUFBTTtJQUNsQjtBQUNGLEVBQUU7QUFFSyxNQUFNcUIsY0FBYyxDQUFDQztJQUMxQixPQUFPNUMsbURBQVdBLENBQUM0QyxPQUFPO0FBQzVCLEVBQUU7QUFFRixvREFBb0Q7QUFDN0MsTUFBTUMsc0JBQXNCLENBQUNyQjtRQUt2QkEsZ0JBRUFBLGlCQUVBQTtJQVJYWixRQUFRWSxLQUFLLENBQUMsbUJBQW1CQTtJQUVqQyxJQUFJQSxNQUFNc0IsTUFBTSxFQUFFO1FBQ2hCLE1BQU0sSUFBSXhCLE1BQU0seUJBQXNDLE9BQWJFLE1BQU1zQixNQUFNO0lBQ3ZELE9BQU8sS0FBSXRCLGlCQUFBQSxNQUFNdUIsT0FBTyxjQUFidkIscUNBQUFBLGVBQWV3QixRQUFRLENBQUMsa0JBQWtCO1FBQ25ELE1BQU0sSUFBSTFCLE1BQU07SUFDbEIsT0FBTyxLQUFJRSxrQkFBQUEsTUFBTXVCLE9BQU8sY0FBYnZCLHNDQUFBQSxnQkFBZXdCLFFBQVEsQ0FBQyx1QkFBdUI7UUFDeEQsTUFBTSxJQUFJMUIsTUFBTTtJQUNsQixPQUFPLEtBQUlFLGtCQUFBQSxNQUFNdUIsT0FBTyxjQUFidkIsc0NBQUFBLGdCQUFld0IsUUFBUSxDQUFDLFlBQVk7UUFDN0MsTUFBTSxJQUFJMUIsTUFBTTtJQUNsQixPQUFPO1FBQ0wsTUFBTSxJQUFJQSxNQUFNO0lBQ2xCO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9ldGhlcnNDb25maWcudHM/NTZiNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBcbiAgQ29udHJhY3QsIFxuICBKc29uUnBjUHJvdmlkZXIsIFxuICBCcm93c2VyUHJvdmlkZXIsXG4gIGZvcm1hdFVuaXRzLCBcbiAgZ2V0QWRkcmVzcyxcbiAgdHlwZSBKc29uUnBjU2lnbmVyLFxuICB0eXBlIFByb3ZpZGVyXG59IGZyb20gJ2V0aGVycyc7XG5cbi8vIFR5cGVzXG5leHBvcnQgaW50ZXJmYWNlIFJlcXVlc3RBcmd1bWVudHMge1xuICBtZXRob2Q6IHN0cmluZztcbiAgcGFyYW1zPzogdW5rbm93bltdIHwgb2JqZWN0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV0aGVyZXVtUHJvdmlkZXIge1xuICByZXF1ZXN0KGFyZ3M6IFJlcXVlc3RBcmd1bWVudHMpOiBQcm9taXNlPHVua25vd24+O1xuICBvbj8oZXZlbnROYW1lOiBzdHJpbmcsIGNhbGxiYWNrOiAoLi4uYXJnczogYW55W10pID0+IHZvaWQpOiB2b2lkO1xuICByZW1vdmVMaXN0ZW5lcj8oZXZlbnROYW1lOiBzdHJpbmcsIGNhbGxiYWNrOiAoLi4uYXJnczogYW55W10pID0+IHZvaWQpOiB2b2lkO1xuICBzZWxlY3RlZEFkZHJlc3M/OiBzdHJpbmc7XG4gIGlzTWV0YU1hc2s/OiBib29sZWFuO1xuICBjaGFpbklkPzogc3RyaW5nO1xuICBuZXR3b3JrVmVyc2lvbj86IHN0cmluZztcbn1cblxuLy8gQWRkIHR5cGUgZGVjbGFyYXRpb24gZm9yIHRoZSBnbG9iYWwgd2luZG93IG9iamVjdFxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBldGhlcmV1bT86IEV0aGVyZXVtUHJvdmlkZXI7XG4gIH1cbn1cblxuLy8gTmV0d29yayBjb25maWd1cmF0aW9uXG5leHBvcnQgY29uc3QgRVhQRUNURURfTkVUV09SSyA9IHtcbiAgY2hhaW5JZDogJzEzMzcnLFxuICBjaGFpbklkSGV4OiAnMHg1MzknLCAvLyBIZXhhZGVjaW1hbCByZXByZXNlbnRhdGlvbiBvZiAxMzM3XG4gIG5hbWU6ICdMb2NhbGhvc3QnLFxuICBycGNVcmw6ICdodHRwOi8vMTI3LjAuMC4xOjc1NDUnLFxuICBuYXRpdmVDdXJyZW5jeToge1xuICAgIG5hbWU6ICdFVEgnLFxuICAgIHN5bWJvbDogJ0VUSCcsXG4gICAgZGVjaW1hbHM6IDE4XG4gIH1cbn07XG5cbi8vIEZ1bmN0aW9uIHRvIHN3aXRjaCB0byB0aGUgY29ycmVjdCBuZXR3b3JrXG5leHBvcnQgY29uc3Qgc3dpdGNoVG9Db3JyZWN0TmV0d29yayA9IGFzeW5jIChldGhlcmV1bTogRXRoZXJldW1Qcm92aWRlcikgPT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIHRvIHN3aXRjaCBuZXR3b3JrLi4uJyk7XG4gICAgLy8gRmlyc3QgY2hlY2sgY3VycmVudCBuZXR3b3JrXG4gICAgY29uc3QgY3VycmVudENoYWluSWQgPSBhd2FpdCBldGhlcmV1bS5yZXF1ZXN0KHsgbWV0aG9kOiAnZXRoX2NoYWluSWQnIH0pO1xuICAgIGNvbnNvbGUubG9nKCdDdXJyZW50IGNoYWluSWQ6JywgY3VycmVudENoYWluSWQpO1xuICAgIFxuICAgIGlmIChjdXJyZW50Q2hhaW5JZCA9PT0gRVhQRUNURURfTkVUV09SSy5jaGFpbklkSGV4KSB7XG4gICAgICBjb25zb2xlLmxvZygnQWxyZWFkeSBvbiBjb3JyZWN0IG5ldHdvcmsnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnU3dpdGNoaW5nIHRvIG5ldHdvcms6JywgRVhQRUNURURfTkVUV09SSy5jaGFpbklkSGV4KTtcbiAgICBcbiAgICAvLyBUcnkgdG8gc3dpdGNoIHRvIHRoZSBuZXR3b3JrXG4gICAgYXdhaXQgZXRoZXJldW0ucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6ICd3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpbicsXG4gICAgICBwYXJhbXM6IFt7IGNoYWluSWQ6IEVYUEVDVEVEX05FVFdPUksuY2hhaW5JZEhleCB9XVxuICAgIH0pO1xuICAgIFxuICAgIC8vIFdhaXQgYSBiaXQgZm9yIHRoZSBuZXR3b3JrIHN3aXRjaCB0byBjb21wbGV0ZVxuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XG4gICAgXG4gICAgLy8gVmVyaWZ5IHRoZSBzd2l0Y2ggd2FzIHN1Y2Nlc3NmdWxcbiAgICBjb25zdCBuZXdDaGFpbklkID0gYXdhaXQgZXRoZXJldW0ucmVxdWVzdCh7IG1ldGhvZDogJ2V0aF9jaGFpbklkJyB9KTtcbiAgICBpZiAobmV3Q2hhaW5JZCAhPT0gRVhQRUNURURfTkVUV09SSy5jaGFpbklkSGV4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05ldHdvcmsgc3dpdGNoIGZhaWxlZCcpO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IHN3aXRjaGVkIHRvIGNvcnJlY3QgbmV0d29yaycpO1xuICB9IGNhdGNoIChzd2l0Y2hFcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gc3dpdGNoVG9Db3JyZWN0TmV0d29yazonLCBzd2l0Y2hFcnJvcik7XG4gICAgXG4gICAgLy8gVGhpcyBlcnJvciBjb2RlIGluZGljYXRlcyB0aGF0IHRoZSBjaGFpbiBoYXMgbm90IGJlZW4gYWRkZWQgdG8gTWV0YU1hc2tcbiAgICBpZiAoc3dpdGNoRXJyb3IuY29kZSA9PT0gNDkwMikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coJ05ldHdvcmsgbm90IGZvdW5kLCBhdHRlbXB0aW5nIHRvIGFkZC4uLicpO1xuICAgICAgICBhd2FpdCBldGhlcmV1bS5yZXF1ZXN0KHtcbiAgICAgICAgICBtZXRob2Q6ICd3YWxsZXRfYWRkRXRoZXJldW1DaGFpbicsXG4gICAgICAgICAgcGFyYW1zOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNoYWluSWQ6IEVYUEVDVEVEX05FVFdPUksuY2hhaW5JZEhleCxcbiAgICAgICAgICAgICAgY2hhaW5OYW1lOiBFWFBFQ1RFRF9ORVRXT1JLLm5hbWUsXG4gICAgICAgICAgICAgIHJwY1VybHM6IFtFWFBFQ1RFRF9ORVRXT1JLLnJwY1VybF0sXG4gICAgICAgICAgICAgIG5hdGl2ZUN1cnJlbmN5OiBFWFBFQ1RFRF9ORVRXT1JLLm5hdGl2ZUN1cnJlbmN5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFdhaXQgYSBiaXQgZm9yIHRoZSBuZXR3b3JrIHRvIGJlIGFkZGVkXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBWZXJpZnkgdGhlIG5ldHdvcmsgd2FzIGFkZGVkIGFuZCBzd2l0Y2hlZCB0b1xuICAgICAgICBjb25zdCBmaW5hbENoYWluSWQgPSBhd2FpdCBldGhlcmV1bS5yZXF1ZXN0KHsgbWV0aG9kOiAnZXRoX2NoYWluSWQnIH0pO1xuICAgICAgICBpZiAoZmluYWxDaGFpbklkICE9PSBFWFBFQ1RFRF9ORVRXT1JLLmNoYWluSWRIZXgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05ldHdvcmsgYWRkIGZhaWxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IGFkZGVkIGFuZCBzd2l0Y2hlZCB0byBuZXR3b3JrJyk7XG4gICAgICB9IGNhdGNoIChhZGRFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgbmV0d29yazonLCBhZGRFcnJvcik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcign2YrYsdis2Ykg2KXYttin2YHYqSDYp9mE2LTYqNmD2Kkg2KfZhNmF2K3ZhNmK2Kkg2YrYr9mI2YrYp9mLIHwgUGxlYXNlIGFkZCB0aGUgbG9jYWwgbmV0d29yayBtYW51YWxseScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzd2l0Y2hpbmcgbmV0d29yazonLCBzd2l0Y2hFcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ9mK2LHYrNmJINiq2LrZitmK2LEg2KfZhNi02KjZg9ipINil2YTZiSDYp9mE2LTYqNmD2Kkg2KfZhNmF2K3ZhNmK2KkgfCBQbGVhc2Ugc3dpdGNoIHRvIGxvY2FsIG5ldHdvcmsnKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIFByb3ZpZGVyIGFuZCBzaWduZXIgZnVuY3Rpb25zXG5leHBvcnQgY29uc3QgZ2V0UHJvdmlkZXIgPSBhc3luYyAoKSA9PiB7XG4gIGlmICghd2luZG93LmV0aGVyZXVtKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhTWFzayDYutmK2LEg2YXYq9io2KogLSBNZXRhTWFzayBpcyBub3QgaW5zdGFsbGVkJyk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFJlcXVlc3QgYWNjb3VudCBhY2Nlc3NcbiAgICBhd2FpdCB3aW5kb3cuZXRoZXJldW0ucmVxdWVzdCh7IG1ldGhvZDogXCJldGhfcmVxdWVzdEFjY291bnRzXCIgfSk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIHByb3ZpZGVyIHVzaW5nIEJyb3dzZXJQcm92aWRlclxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IEJyb3dzZXJQcm92aWRlcih3aW5kb3cuZXRoZXJldW0pO1xuICAgIFxuICAgIC8vIFZhbGlkYXRlIGFuZCBzd2l0Y2ggbmV0d29yayBpZiBuZWVkZWRcbiAgICBhd2FpdCB2YWxpZGF0ZU5ldHdvcmsocHJvdmlkZXIpO1xuICAgIFxuICAgIHJldHVybiBwcm92aWRlcjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHByb3ZpZGVyOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldFNpZ25lciA9IGFzeW5jICgpOiBQcm9taXNlPEpzb25ScGNTaWduZXI+ID0+IHtcbiAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBnZXRQcm92aWRlcigpO1xuICByZXR1cm4gcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XG59O1xuXG5leHBvcnQgY29uc3QgdmFsaWRhdGVOZXR3b3JrID0gYXN5bmMgKHByb3ZpZGVyOiBQcm92aWRlcikgPT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdWYWxpZGF0aW5nIG5ldHdvcmsuLi4nKTtcbiAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgcHJvdmlkZXIuZ2V0TmV0d29yaygpO1xuICAgIGNvbnN0IGNoYWluSWQgPSBuZXR3b3JrLmNoYWluSWQudG9TdHJpbmcoKTtcbiAgICBjb25zb2xlLmxvZygnQ3VycmVudCBjaGFpbklkOicsIGNoYWluSWQsICdFeHBlY3RlZDonLCBFWFBFQ1RFRF9ORVRXT1JLLmNoYWluSWQpO1xuICAgIFxuICAgIGlmIChjaGFpbklkICE9PSBFWFBFQ1RFRF9ORVRXT1JLLmNoYWluSWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdXcm9uZyBuZXR3b3JrIGRldGVjdGVkJyk7XG4gICAgICBpZiAod2luZG93LmV0aGVyZXVtKSB7XG4gICAgICAgIGF3YWl0IHN3aXRjaFRvQ29ycmVjdE5ldHdvcmsod2luZG93LmV0aGVyZXVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihg2YrYsdis2Ykg2KfZhNin2KrYtdin2YQg2KjYtNio2YPYqSAke0VYUEVDVEVEX05FVFdPUksubmFtZX0gKENoYWluIElEOiAke0VYUEVDVEVEX05FVFdPUksuY2hhaW5JZH0pIHwgUGxlYXNlIGNvbm5lY3QgdG8gJHtFWFBFQ1RFRF9ORVRXT1JLLm5hbWV9IG5ldHdvcmtgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJ05ldHdvcmsgdmFsaWRhdGlvbiBwYXNzZWQnKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignTmV0d29yayB2YWxpZGF0aW9uIGZhaWxlZDonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBjb250cmFjdHNcbmV4cG9ydCBjb25zdCBnZXRDb250cmFjdCA9IDxUIGV4dGVuZHMgQ29udHJhY3Q+KFxuICBhZGRyZXNzOiBzdHJpbmcsXG4gIGFiaTogYW55LFxuICBzaWduZXI6IEpzb25ScGNTaWduZXJcbik6IFQgPT4ge1xuICByZXR1cm4gbmV3IENvbnRyYWN0KGFkZHJlc3MsIGFiaSwgc2lnbmVyKSBhcyBUO1xufTtcblxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlQWRkcmVzcyA9IChhZGRyZXNzOiBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsKTogc3RyaW5nID0+IHtcbiAgaWYgKCFhZGRyZXNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBZGRyZXNzIGlzIHJlcXVpcmVkJyk7XG4gIH1cbiAgXG4gIHRyeSB7XG4gICAgcmV0dXJuIGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEV0aGVyZXVtIGFkZHJlc3MnKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGZvcm1hdEV0aGVyID0gKHZhbHVlOiBiaWdpbnQpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gZm9ybWF0VW5pdHModmFsdWUsIDE4KTtcbn07XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb24gdG8gaGFuZGxlIGNvbW1vbiBjb250cmFjdCBlcnJvcnNcbmV4cG9ydCBjb25zdCBoYW5kbGVDb250cmFjdEVycm9yID0gKGVycm9yOiBhbnkpOiBuZXZlciA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoJ0NvbnRyYWN0IGVycm9yOicsIGVycm9yKTtcbiAgXG4gIGlmIChlcnJvci5yZWFzb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFNtYXJ0IGNvbnRyYWN0IGVycm9yOiAke2Vycm9yLnJlYXNvbn1gKTtcbiAgfSBlbHNlIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygndXNlciByZWplY3RlZCcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiByZWplY3RlZCBieSB1c2VyJyk7XG4gIH0gZWxzZSBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ2luc3VmZmljaWVudCBmdW5kcycpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnN1ZmZpY2llbnQgZnVuZHMgdG8gY29tcGxldGUgdGhlIHRyYW5zYWN0aW9uJyk7XG4gIH0gZWxzZSBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ25ldHdvcmsnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIG1ha2Ugc3VyZSB5b3UgYXJlIGNvbm5lY3RlZCB0byB0aGUgY29ycmVjdCBuZXR3b3JrJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBmYWlsZWQuIFBsZWFzZSBjaGVjayB5b3VyIGNvbm5lY3Rpb24gYW5kIHRyeSBhZ2Fpbi4nKTtcbiAgfVxufTsgIl0sIm5hbWVzIjpbIkNvbnRyYWN0IiwiQnJvd3NlclByb3ZpZGVyIiwiZm9ybWF0VW5pdHMiLCJnZXRBZGRyZXNzIiwiRVhQRUNURURfTkVUV09SSyIsImNoYWluSWQiLCJjaGFpbklkSGV4IiwibmFtZSIsInJwY1VybCIsIm5hdGl2ZUN1cnJlbmN5Iiwic3ltYm9sIiwiZGVjaW1hbHMiLCJzd2l0Y2hUb0NvcnJlY3ROZXR3b3JrIiwiZXRoZXJldW0iLCJjb25zb2xlIiwibG9nIiwiY3VycmVudENoYWluSWQiLCJyZXF1ZXN0IiwibWV0aG9kIiwicGFyYW1zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwibmV3Q2hhaW5JZCIsIkVycm9yIiwic3dpdGNoRXJyb3IiLCJlcnJvciIsImNvZGUiLCJjaGFpbk5hbWUiLCJycGNVcmxzIiwiZmluYWxDaGFpbklkIiwiYWRkRXJyb3IiLCJnZXRQcm92aWRlciIsIndpbmRvdyIsInByb3ZpZGVyIiwidmFsaWRhdGVOZXR3b3JrIiwiZ2V0U2lnbmVyIiwibmV0d29yayIsImdldE5ldHdvcmsiLCJ0b1N0cmluZyIsImdldENvbnRyYWN0IiwiYWRkcmVzcyIsImFiaSIsInNpZ25lciIsInZhbGlkYXRlQWRkcmVzcyIsImZvcm1hdEV0aGVyIiwidmFsdWUiLCJoYW5kbGVDb250cmFjdEVycm9yIiwicmVhc29uIiwibWVzc2FnZSIsImluY2x1ZGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./utils/ethersConfig.ts\n"));

/***/ })

});